#!/bin/bash
# Author: Erland@Hedmanshome.se
p_uptime()
{
   uptime=$(</proc/uptime)
   uptime=${uptime%%.*}

   #seconds=$(( uptime%60 ))
   minutes=$(( uptime/60%60 ))
   hours=$(( uptime/60/60%24 ))
   days=$(( uptime/60/60/24 ))

   echo -n  "$days days, $hours hours, $minutes minutes"
}

doMkKey()
(
    if [ -s /etc/dhcp/ddns.key ] && [ -s /etc/bind/rndc.key ]; then
        return
    fi

    cd /tmp
    /usr/sbin/dnssec-keygen -a HMAC-MD5 -b 128 -r /dev/urandom -n USER DDNS_UPDATE  >/dev/null 2>&1
    key=$(grep Key: Kddns_update*.private | cut -d: -f2 | sed s/" "//)

cat <<End-of-message>/etc/dhcp/ddns.key
key DDNS_UPDATE {
    algorithm HMAC-MD5.SIG-ALG.REG.INT;
    secret "${key}";
};
End-of-message

cat <<End-of-message>/etc/bind/rndc.key
key "rndc-key" {
        algorithm hmac-md5;
        secret "${key}";
};
End-of-message

    rm -f Kddns*

    cd -  >/dev/null 2>&1
)

do_nlist()
{
    if=$3
    nw=$(ip addr show ${if} | grep -v secondary | awk -F/ '/inet /{ print $1 }' | awk '{ print $NF }' | cut -d. -f1-3)
    if [ -z ${nw} ]; then
        echo "" > /tmp/hostopts
        return
    fi

    nbtscan -e ${nw}.1-253 | awk '{printf "<option value=%s%s%s>%s</option>","\"",$1,"\"",tolower($2)}' >/tmp/hostopts &
}

do_hlist()
{
    dm=$2
    if [ -z "$dm" ]; then
        dm=$(grep search /etc/resolv.conf | awk '{print $2}')
        if [ -z "$dm" ]; then return; fi
    fi
    host -W 2 -l $dm 127.0.0.1 | awk 'NR>6{gsub(".'${dm}'", "");printf "<option value=%s%s%s>%s</option>","\"",$4,"\"",$1}' >/tmp/hostopts &

}

do_hostopts()
{
    pidof named > /dev/null

    if [ $? -eq 0 ]; then
        do_hlist $*
    else
        do_nlist $*
    fi
}

do_wifilist()
{
    if [ -f /proc/net/wireless ]; then
        ifs=$(cat /proc/net/wireless | awk -F: 'NR>2{printf "%s", $1}')
        echo -n "["
        for if in $ifs; do
            echo -n '"'$if'", '
        done
        echo -n '"0"]'
    else
        echo -n '["0"]'
    fi
}

do_ifopts()
{
    devs=$(grep : /proc/net/dev | cut -d: -f1 | grep -v lo | awk '{printf "%s ", $NF}')

    for dev in $devs
    do
        echo -n "<option value='$dev'"
        if [ "$2" = "$dev" ]; then echo -n " selected='selected'"; fi
        echo -n ">$dev</option>"
    done
}

do_setstatic()
{
    cp /etc/network/interfaces /etc/network/interfaces.old
    shift 1

    wan=${8}
    lan=${9}
    lan1_if=${10}
    srvif=${11}
    srvip=${12}

    grep -q ${wan} /proc/net/wireless > /dev/null 2>&1
    if [ $? -gt 0 ]; then dis="#na"; fi

    cat <<End-of-message>/etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

# The loopback network interface
auto lo
iface lo inet loopback

allow-hotplug ${lan}
allow-hotplug ${wan}

auto ${wan}
iface ${wan} inet static
    address ${1}
    netmask ${2}
    gateway ${3}
$dis    wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
    post-up iptables -t nat -A POSTROUTING -o \$IFACE -j MASQUERADE
    post-up echo 1 > /proc/sys/net/ipv4/ip_forward
    post-down echo 0 > /proc/sys/net/ipv4/ip_forward

auto ${lan}
iface ${lan} inet static
    address ${5}
    netmask ${6}
End-of-message

    echo ${4} > /etc/hostname; hostname -F /etc/hostname
    
    /sbin/shorewall stop
    /sbin/shorewall clear

    diff --ignore-blank-lines /etc/network/interfaces /etc/network/interfaces.old > /dev/null
    if [ $? -gt 0 ]; then
        /sbin/ifdown -a --force
        sleep 1
        /sbin/ifup -a --force
        sleep 1

        pidof named >/tmp/null
        if [ $? -eq 0 ]; then               
            grep -q 'redir_here=y' /etc/bind/null.zone.file
            if [ $? -eq 0 ]; then
                rd=$(grep '*' /etc/bind/null.zone.file | awk '{print $4}')
                /sbin/ifconfig ${lan1_if} ${rd} up
            fi
            /usr/sbin/service bind9 stop
        fi

        dhif=$(grep interface /etc/dhcp/dhcpd.conf | awk -F\" '{printf "%s", $2}')
        if [ -n "${dhif}" ]; then
            sed /${dhif}/s//${lan}/g /etc/dhcp/dhcpd.conf > /tmp/dhif
            if [ -f /tmp/dhif ]; then
                cp /tmp/dhif /etc/dhcp/dhcpd.conf
                pidof dhcpd >/tmp/null
                if [ $? -eq 0 ]; then
                    /usr/sbin/service isc-dhcp-server stop
                fi
            fi
        fi

        newlan=$(tail -n 4 /etc/network/interfaces)
        oldlan=$(tail -n 4 /etc/network/interfaces.old)

        if [ "${oldlan}" != "${newlan}" ]; then
            /usr/sbin/service bind9 stop
            /usr/sbin/service isc-dhcp-server stop
            echo "" > /var/lib/dhcp*/dhcpd.leases
            rm -f /etc/bind/db*.jnl
        fi

        pidof hostapd > /dev/null
        if [ $? -eq 0 ]; then
            /usr/sbin/service hostapd stop
            grep -q ${lan} /proc/net/wireless
            if [ $? -eq 0 ]; then
                haif=$(grep -m1 interface /etc/hostapd/hostapd.conf | awk -F= '{printf "%s", $2}')
                if [ -n "${haif}" ]; then
                    sed /${haif}/s//${lan}/g /etc/hostapd/hostapd.conf > /tmp/haif
                    if [ -f /tmp/haif ]; then
                        cp /tmp/haif  /etc/hostapd/hostapd.conf
                        /usr/sbin/service hostapd start
                    fi
                fi
            fi
        fi
    fi

    do_firewall_masqif na ${wan} ${lan} ${srvif} ${srvip}

    if [ -f /etc/shorewall/tcinterfaces ]; then
        data=$(grep mbit /etc/shorewall/tcinterfaces | awk '{printf "%s %s\n", $3,$4}' | sed /mbit/s///g)
        do_firewall_ts na 1  ${data} ${wan}
    fi

    diff --ignore-blank-lines /etc/network/interfaces /etc/network/interfaces.old > /dev/null
    if [ $? -eq 0 ]; then
        grep -q "startup=1" /etc/default/shorewall
        if [ $? -eq 0 ]; then
            /sbin/shorewall start
        fi
    fi
}

do_setdhcp()
{
    cp /etc/network/interfaces /etc/network/interfaces.old
    shift 1

    wan=${5}
    lan=${6}
    lan1_if=${7}
    srvif=${8}
    srvip=${9}

    grep -q ${wan} /proc/net/wireless > /dev/null 2>&1
    if [ $? -gt 0 ]; then dis="#na"; fi

    cat <<End-of-message>/etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

# The loopback network interface
auto lo
iface lo inet loopback

allow-hotplug ${lan}
allow-hotplug ${wan}

auto ${wan}
iface ${wan} inet dhcp 
$dis    wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
    post-up iptables -t nat -A POSTROUTING -o \$IFACE -j MASQUERADE
    post-up echo 1 > /proc/sys/net/ipv4/ip_forward
    post-down echo 0 > /proc/sys/net/ipv4/ip_forward

auto ${lan}
iface ${lan} inet static
    address ${2}
    netmask ${3}
End-of-message

    echo ${1} > /etc/hostname; hostname -F /etc/hostname

    /sbin/shorewall stop
    /sbin/shorewall clear

    diff --ignore-blank-lines /etc/network/interfaces /etc/network/interfaces.old > /dev/null
    if [ $? -gt 0 ]; then
        /sbin/ifdown -a --force
        sleep 1
        /sbin/ifup -a --force
        sleep 1

        pidof named >/tmp/null
        if [ $? -eq 0 ]; then               
            grep -q 'redir_here=y' /etc/bind/null.zone.file
            if [ $? -eq 0 ]; then
                rd=$(grep '*' /etc/bind/null.zone.file | awk '{print $4}')
                /sbin/ifconfig ${lan1_if} ${rd} up
            fi
            /usr/sbin/service bind9 stop
        fi

        dhif=$(grep interface /etc/dhcp/dhcpd.conf | awk -F\" '{printf "%s", $2}')
        if [ -n "${dhif}" ]; then
            sed /${dhif}/s//${lan}/g /etc/dhcp/dhcpd.conf > /tmp/dhif
            if [ -f /tmp/dhif ]; then
                cp /tmp/dhif /etc/dhcp/dhcpd.conf
                pidof dhcpd >/tmp/null
                if [ $? -eq 0 ]; then
                    /usr/sbin/service isc-dhcp-server stop
                fi
            fi
        fi

        newlan=$(tail -n 4 /etc/network/interfaces)
        oldlan=$(tail -n 4 /etc/network/interfaces.old)

        if [ "${oldlan}" != "${newlan}" ]; then
            /usr/sbin/service bind9 stop
            /usr/sbin/service isc-dhcp-server stop
            echo "" > /var/lib/dhcp*/dhcpd.leases
            rm -f /etc/bind/db*.jnl
        fi

        pidof hostapd > /dev/null
        if [ $? -eq 0 ]; then
            /usr/sbin/service hostapd stop
            grep -q ${lan} /proc/net/wireless
            if [ $? -eq 0 ]; then
                haif=$(grep -m1 interface /etc/hostapd/hostapd.conf | awk -F= '{printf "%s", $2}')
                if [ -n "${haif}" ]; then
                    sed /${haif}/s//${lan}/g /etc/hostapd/hostapd.conf > /tmp/haif
                    if [ -f /tmp/haif ]; then
                        cp /tmp/haif  /etc/hostapd/hostapd.conf
                        /usr/sbin/service hostapd start
                    fi
                fi
            fi
        fi
    fi

    do_firewall_masqif na ${wan} ${lan} ${srvif} ${srvip}

    if [ -f /etc/shorewall/tcinterfaces ]; then
        data=$(grep mbit /etc/shorewall/tcinterfaces | awk '{printf "%s %s\n", $3,$4}' | sed /mbit/s///g)
        do_firewall_ts na 1  ${data} ${wan}
    fi

    diff --ignore-blank-lines /etc/network/interfaces /etc/network/interfaces.old > /dev/null
    if [ $? -eq 0 ]; then
        grep -q "startup=1" /etc/default/shorewall
        if [ $? -eq 0 ]; then
            /sbin/shorewall start
        fi
    fi
}

do_hostapd()
{
    
    if [ "${1}" = "2" ]; then wpa=1; else wpa=3; fi   
    if=${2}
    ssid=${3}
    pp=${4}
    cip=${5}
    cha=${6}
    mode=${7}
    cou=${8}
    visi=${9}
    drv=${10}
   
    if [ "${mode}" = "gn" ]; then
        mode="g"
        m11n="1"
    else
        m11n="0" 
    fi

    if [ "${cip}" = "2" ]; then cipher="TKIP"; else cipher=""; fi

    cat <<End-of-message>/etc/hostapd/hostapd.conf
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
interface=${if}
driver=${drv}
country_code=${cou}
ctrl_interface=${if}
ctrl_interface_group=0
ssid=${ssid}
hw_mode=${mode}
channel=${cha}
wpa=${wpa}
wpa_passphrase=${pp}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP ${cipher}
rsn_pairwise=CCMP
beacon_int=100
auth_algs=3
macaddr_acl=0
wmm_enabled=1
ieee80211n=${m11n}
eap_reauth_period=360000000
ignore_broadcast_ssid=${visi}
End-of-message

/usr/sbin/service hostapd restart

}

udec=""
urldecode()
{                                                                               
    local url_encoded="${1//+/ }"
    udec=$(printf '%b' "${url_encoded//%/\x}")
} 

do_setwep()
{
    /sbin/ifdown --force ${3}
   
    urldecode ${1}
    cat <<End-of-message>/etc/wpa_supplicant/wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
        ssid="${udec}"
        key_mgmt=NONE
        wep_key0="${2}"
        wep_tx_keyidx=0
} 
End-of-message
    /sbin/ifup ${3} >/dev/null 2>&1; sleep 2;
}

do_setwpapsk()
{
    /sbin/ifdown --force ${5}
    # WPA2 bukefalos 090e0b0c0d 2 wlan0

    urldecode ${2}
    if [ "${1}" = "WPA2" ]; then proto="RSN"; else proto="WPA"; fi
    if [ ${4} -eq 2 ]; then cipher="TKIP"; fi
    if [ ${4} -eq 3 ]; then
        if [ "${1}" = "WPA2" ];
            then cipher=""; 
        fi
    fi

cat <<End-of-message>/etc/wpa_supplicant/wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
        ssid="${udec}"
        proto=${proto}
        key_mgmt=WPA-PSK
        pairwise=CCMP ${cipher}
        group=CCMP ${cipher}
        psk="${3}"
} 
End-of-message
    /sbin/ifup ${5} >/dev/null 2>&1; sleep 2;
}

do_dhcpd()
{
    doMkKey

    if [ ${3} -eq 1 ]; then server=true; else server=false; fi
    shift 3

    lan_ip=${1}
    lan_mask=${2}
    domain=${7}
    wan_if=${11}
    lan_if=${12}
    lan1_if=${13}

    if [ ${6} -eq 1 ]; then remove_res=true; else remove_res=false; fi
   
    if [ ${10} -eq 1 ]; then
        relay="# dns-relay true" 
        resolv=$(grep -m1 nameserver /etc/resolv.conf | awk '{printf "%s", $2}')
        r2=$(grep nameserver /etc/resolv.conf | awk '{printf "%s ", $2}' | awk '{print $2}')
        if [ -n "${r2}" ]; then
            resolv="${resolv}, ${r2}"
        fi
    else
        relay="#"
        resolv="${8}"
        if [ -n "${9}" ]; then
            resolv="${8}, ${9}"
        fi
    fi  

    sub=$(ipcalc -b ${lan_ip} ${lan_mask} | grep Network: | awk '{print $2 }' | cut -d/ -f1)
    broadc=$(ipcalc ${sub}/${lan_mask} | grep Broadcast | awk '{print $2}')
    iprev=$(echo ${sub} | sed s/"\."/" "/g | awk '{print $3"."$2"."$1}')

    rzone="${iprev}.in-addr.arpa"
    filedns="/tmp/dnsbatch-1.txt"

    if [ ${server} = true ]; then
        file="/etc/dhcp/dhcpd.conf"
    else
        file=/dev/null
    fi

cat <<End-of-message>${file}
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
${relay}
ddns-update-style       interim;
ignore                  client-updates;
update-static-leases    on;

authoritative;

include "/etc/dhcp/ddns.key";

zone ${domain}. {
  primary 127.0.0.1;
  key "DDNS_UPDATE";
}

zone ${iprev}.in-addr.arpa. {
  primary 127.0.0.1;
  key "DDNS_UPDATE";
}

log-facility local7;
max-lease-time 86400;

subnet ${sub} netmask ${lan_mask} {
  interface "${lan_if}";
  range ${3} ${4};
  option domain-name "${domain}";
  option domain-name-servers ${resolv};
  option routers ${lan_ip};
  option broadcast-address ${broadc};
  default-lease-time ${5};
}
End-of-message
    shift 13

# Fixed IP addresses

    echo "# Fixed IP addresses" >> ${file}
    echo "server ${lan_ip}" >${filedns}
    cnt=$#

    while true
    do
    if [ ${cnt} -le 0 ]; then break; fi

        rv=$(echo ${3}|sed s/"\."/" "/g|awk '{printf "%s.%s.%s.%s.in-addr.arpa",$4,$3,$2,$1}')
        echo "zone ${domain}" >> ${filedns} 
        echo "update delete ${4}.${domain}" >> ${filedns}
        echo "send" >> ${filedns}
        echo "zone ${rzone}" >> ${filedns} 
        echo "update delete ${rv}. PTR ${4}.${domain}." >> ${filedns}
        echo "send" >> ${filedns}       

        if [ ${1} -eq 3 ]; then 
            shift 4
            let cnt=${cnt}-4         
            continue;
        fi

        if [ ${1} -eq 2 ] || [ ${1} -eq 0 ]; then
            rmadynlease ${2} ${lan_if}
        fi
        
        if [ ${1} -eq 0 ]; then d="#"; else d=""; fi

        echo "${d}host ${4}.${domain} {" >> ${file}
        echo "${d}    hardware ethernet ${2};" >> ${file}
        echo "${d}    fixed-address ${3};" >> ${file}
        echo "${d}}" >> ${file}

        if [ ${1} -eq  1 ]; then
            echo "zone ${domain}" >> ${filedns}     
            echo "update add ${4}.${domain} 86400 A ${3}" >> ${filedns}
            echo "send" >> ${filedns}
            echo "zone ${rzone}" >> ${filedns}
            echo "update add ${rv}. 86400 PTR ${4}.${domain}." >> ${filedns}
            echo "send" >> ${filedns}
        fi

        shift 4
        let cnt=${cnt}-4
    done

    cip=$(grep -m1 -A1 "iface ${lan_if} inet static" /etc/network/interfaces | grep address | awk '{print $2}')
    cat /etc/network/interfaces | sed /"${cip}"/s//"${lan_ip}"/ >/tmp/ifs
    
    if [ -s /tmp/ifs ]; then
        cp /etc/network/interfaces  /etc/network/interfaces.old
        cp /tmp/ifs /etc/network/interfaces
    fi
    rm -f /tmp/ifs

    pidof named >/tmp/null
    if [ $? -eq 0 ]; then 
        key=$(cat /etc/dhcp/ddns.key  | grep key | awk '{print $2}')
        sec=$(cat /etc/dhcp/ddns.key  | grep secret | awk -F\" '{print $2}')
        /usr/bin/nsupdate -y "${key}:${sec}" ${filedns}
    fi

    diff --ignore-blank-lines /etc/network/interfaces /etc/network/interfaces.old > /dev/null
    if [ $? -gt 0 ]; then
        /sbin/ifdown -a --force
        sleep 1
        /sbin/ifup -a --force
        sleep 1

        pidof named >/tmp/null
        if [ $? -eq 0 ]; then               
            grep -q 'redir_here=y' /etc/bind/null.zone.file
            if [ $? -eq 0 ]; then
                rd=$(grep '*' /etc/bind/null.zone.file | awk '{print $4}')
                /sbin/ifconfig ${lan1_if} ${rd} up
            fi
        fi

        newlan=$(tail -n 4 /etc/network/interfaces)
        oldlan=$(tail -n 4 /etc/network/interfaces.old)

        if [ "${oldlan}" != "${newlan}" ]; then
            /usr/sbin/service bind9 stop
            /usr/sbin/service isc-dhcp-server stop
            echo "" > /var/lib/dhcp*/dhcpd.leases
            rm -f /etc/bind/db*.jnl
        fi
    fi
}

do_updatedhcp()
{
    primary=${1}
    secondary=${2}
    if [ -n  "${secondary}" ]; then
        npattern="${primary}, ${secondary};"
        pattern=$(grep 'option domain-name-servers' /etc/dhcp/dhcpd.conf | awk '{print $2" "$3" "$4}')
    else
        npattern="${primary},"
        pattern=$(grep 'option domain-name-servers' /etc/dhcp/dhcpd.conf | awk '{print $2" "$3}')
    fi

    pidof dhcpd > /dev/null
    if [ $? -eq 0 ]; then
        cat /etc/dhcp/dhcpd.conf | sed s/"${pattern}"/"domain-name-servers ${npattern}"/ >/tmp/udhcp
        if [ -s /tmp/udhcp ]; then
            cp /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.old
            cp /tmp/udhcp /etc/dhcp/dhcpd.conf
            diff --ignore-blank-lines /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.old > /dev/null
            if [ $? -gt 0 ]; then
                /usr/sbin/service isc-dhcp-server restart
            fi
        fi
    fi
    rm -f /tmp/udhcp
}

do_rangecheck()
{
    dip=${1}
    mask=${2}
    sip=${3}
    eip=${4}
    netw=$(ipcalc -b ${dip} ${mask} | grep Network: | awk '{print $2 }' | cut -d/ -f1)
    sipn=$(ipcalc -b ${sip} ${mask} | grep Network: | awk '{print $2 }' | cut -d/ -f1)
    eipn=$(ipcalc -b ${eip} ${mask} | grep Network: | awk '{print $2 }' | cut -d/ -f1)

    if [ "${sipn}" = "${netw}" ] &&  [ "${eipn}" = "${netw}" ]; then
        echo "" > /tmp/netrange
    else
        echo "${netw}" > /tmp/netrange
    fi
}

do_dbhome()
{
    doMkKey

    if [ ${3} -eq 1 ]; then dns_enable=true; else dns_enable=false; fi
    if [ ${4} -eq 1 ]; then bl_enable=true; else bl_enable=false; fi
    if [ ${5} -eq 1 ]; then bl_updates=true; else bl_updates=false; fi
    if [ ${6} -eq 1 ]; then gg_jumps=true; else gg_jumps=false; fi
    dnsfw_1=${7}
    dnsfw_2=${8}
    serving_net=${9}
    domain=${10}
    redir_spf=${11}
    spf_here=${12}
    lan_if=${13}
    lan1_if=${14}

    
    thishost=$(hostname)
    thisip=$(ip addr show ${lan_if} | grep -v secondary | awk -F/ '/inet /{ print $1 }' | awk '{ print $NF }')

    file=/etc/bind/db.${domain}

cat <<End-of-message>${file}
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
\$TTL    604800
@       IN      SOA     ${thishost}.${domain}. root.${domain}. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@	IN	NS	${thishost}.${domain}.
\$ORIGIN ${domain}.
${thishost}	A	${thisip}
End-of-message

    shift 17

    cnt=$#
    while true
    do
    if [ ${cnt} -le 0 ]; then break; fi
        if [ ${1} -eq 1 ]; then
            echo -e ${2}'\t'"A"'\t'${3}>> ${file}
        fi
        shift 3
        let cnt=${cnt}-3
    done
}

do_dbrev()
{
    doMkKey
    if [ ${3} -eq 1 ]; then dns_enable=true; else dns_enable=false; fi
    if [ ${4} -eq 1 ]; then bl_enable=true; else bl_enable=false; fi
    if [ ${5} -eq 1 ]; then bl_updates=true; else bl_updates=false; fi
    if [ ${6} -eq 1 ]; then gg_jumps=true; else gg_jumps=false; fi
    dnsfw_1=${7}
    dnsfw_2=${8}
    serving_net=${9}
    domain=${10}
    redir_spf=${11}
    lan_if=${13}
    lan1_if=${14}

    if [ ${12} -eq 1 ]; then spf_here="redir_here=y"; else spf_here="redir_here=n"; fi

    shift 8

    thisip=$(ip addr show ${lan_if} | grep -v secondary | awk -F/ '/inet /{ print $1 }' | awk '{ print $NF }')
    iprev=$(echo ${serving_net} | sed s/"\."/" "/g | awk '{print $3"."$2"."$1}')
   
    thishost=$(hostname)

    if [ ${bl_enable} = true ]; then
        blist='include "/etc/bind/blacklist";'
    fi

    file=/etc/bind/db.${iprev}

cat <<End-of-message>${file}
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
\$TTL    604800
@       IN      SOA     ${thishost}.${domain}. root.${domain}. (
                              2         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
@	IN	NS	${thishost}.
;
End-of-message

    shift 6
    cnt=$#
    while true
    do
    if [ ${cnt} -le 0 ]; then break; fi
        if [ ${1} -eq 1 ]; then
            tail=$(echo ${3} | cut -d. -f4)
            echo -e ${tail}'\t'"IN"'\t'"PTR"'\t'${2}.${domain}.>> ${file}
        fi
        shift 3
        let cnt=${cnt}-3
    done

    file=/etc/bind/named.conf.local
cat <<End-of-message>${file}
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
include "/etc/bind/zones.rfc1918";
include "/etc/bind/rndc.key";
include "/etc/dhcp/ddns.key";
${blist}

controls {
        inet 127.0.0.1 allow { localhost; } keys { "DDNS_UPDATE"; };
};

zone "${domain}" {
        type master;
        file "/etc/bind/db.${domain}";
        allow-update { key "DDNS_UPDATE"; };
};

zone "${iprev}.in-addr.arpa" {
        type master;
        file "/etc/bind/db.${iprev}";
        allow-update { key "DDNS_UPDATE"; };
};
End-of-message

    file=/etc/bind/named.conf.options
cat <<End-of-message>${file}
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
options {
        directory "/var/cache/bind";
        managed-keys-directory "/var/named/dynamic";
        listen-on { 127.0.0.1; ${thisip}; };
        listen-on-v6 { none; };

        allow-recursion { any; };
        allow-query { any; };
        allow-query-cache { any; };

        forwarders {
                ${dnsfw_1};
                ${dnsfw_2};
                80.251.201.177;
                80.251.201.178;
        };
        
        dnssec-enable no;
        dnssec-validation no;

        auth-nxdomain no;
};
End-of-message

    file=/etc/bind/null.zone.file
cat <<End-of-message>${file}
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
; ${spf_here}
\$TTL    86400   ; one day
        
@	IN		SOA		${thishost}.${domain}. root.${domain}. (
            2002061000       ; serial number YYMMDDNN
            28800   ; refresh  8 hours 
            7200    ; retry    2 hours
            864000  ; expire  10 days
            86400 ) ; min ttl  1 day
	NS      ${thishost}.${domain}
        
			A		${redir_spf}
;
@	IN		A		${redir_spf}
*	IN		A		${redir_spf}
End-of-message

    serving_net_in=$(echo ${serving_net} | cut -d. -f1-2 | sed s/"\."/" "/| awk '{print $2"."$1}')

file=/etc/bind/zones.rfc1918
cat <<End-of-message>${file}
zone "10.in-addr.arpa"      { type master; file "/etc/bind/db.empty"; };
zone "16.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "17.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "18.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "19.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "20.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "21.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "22.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "23.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "24.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "25.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "26.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "27.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "28.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "29.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "30.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "31.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "${serving_net_in}.in-addr.arpa" { type master; file "/etc/bind/db.empty"; };
End-of-message

    chown bind:bind /etc/bind/*

    if [ ${dns_enable} = true ]; then
        /usr/sbin/service bind9 restart
        if [ ${spf_here} = "redir_here=y" ]; then
            /sbin/ifconfig ${lan1_if} ${redir_spf} up
        else
            /sbin/ifconfig ${lan1_if} down
        fi
    else
        /usr/sbin/service bind9 stop
        /sbin/ifconfig ${lan1_if} down
    fi 
}

do_updatedns()
{
    shift 1
    dnsfw_1=${1}
    dnsfw_2=${2}
    redir_spf=${3}
    domain=${5}
    serving_net=${7}
    lan_if=${8}
    lan1_if=${9}

    if [ ${4} -eq 1 ]; then spf_here="redir_here=y"; else spf_here="redir_here=n"; fi
    if [ ${6} -eq 1 ]; then bl_enable=true; else bl_enable=false; fi
    thisip=$(ip addr show ${lan_if} | grep -v secondary | awk -F/ '/inet /{ print $1 }' | awk '{ print $NF }')
    thishost=$(hostname)
    if [ ${bl_enable} = true ]; then
        blist='include "/etc/bind/blacklist";'
    fi
    iprev=$(echo ${serving_net} | sed s/"\."/" "/g | awk '{print $3"."$2"."$1}')

    if [ ${bl_enable} = true ] && [ ${4} -eq 1 ]; then
        ifconfig ${lan1_if} ${redir_spf} up
    else
        ifconfig ${lan1_if} down
    fi

    file=/etc/bind/named.conf.options
    cat <<End-of-message>${file}
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
options {
        directory "/var/cache/bind";
        managed-keys-directory "/var/named/dynamic";
        listen-on { 127.0.0.1; ${thisip}; };
        listen-on-v6 { none; };

        allow-recursion { any; };
        allow-query { any; };
        allow-query-cache { any; };

        forwarders {
                ${dnsfw_1};
                ${dnsfw_2};
                80.251.201.177;
                80.251.201.178;
        };

        dnssec-enable no;
        dnssec-validation no;

        auth-nxdomain no;
};
End-of-message

    file=/etc/bind/null.zone.file
cat <<End-of-message>${file}
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
; ${spf_here}
\$TTL    86400   ; one day
        
@	IN		SOA		${thishost}.${domain}. root.${domain}. (
            2002061000       ; serial number YYMMDDNN
            28800   ; refresh  8 hours 
            7200    ; retry    2 hours
            864000  ; expire  10 days
            86400 ) ; min ttl  1 day
	NS      ${thishost}.${domain}
        
			A		${redir_spf}
;
@	IN		A		${redir_spf}
*	IN		A		${redir_spf}
End-of-message

    file=/etc/bind/named.conf.local
cat <<End-of-message>${file}
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
include "/etc/bind/zones.rfc1918";
include "/etc/bind/rndc.key";
include "/etc/dhcp/ddns.key";
${blist}

controls {
        inet 127.0.0.1 allow { localhost; } keys { "DDNS_UPDATE"; };
};

zone "${domain}" {
        type master;
        file "/etc/bind/db.${domain}";
        allow-update { key "DDNS_UPDATE"; };
};

zone "${iprev}.in-addr.arpa" {
        type master;
        file "/etc/bind/db.${iprev}";
        allow-update { key "DDNS_UPDATE"; };
};
End-of-message

}

do_dbrecords()
{
    file=/tmp/dnsbatch.txt

    domain=${10}
    rzn=$(echo ${9}|sed s/"\."/" "/g|awk '{printf "%s.%s.%s.in-addr.arpa",$3,$2,$1}')
    shift 14

    cnt=$#
    if [ ${cnt} -le 1 ]; then return; fi

    echo "server 127.0.0.1" >${file}

    while true
    do
    if [ ${cnt} -le 0 ]; then break; fi
        if [ ${1} -gt 0 ]; then
            rv=$(echo ${3}|sed s/"\."/" "/g|awk '{printf "%s.%s.%s.%s.in-addr.arpa",$4,$3,$2,$1}')
            echo "zone ${domain}" >> ${file} 
            echo "update delete ${2}.${domain}" >> ${file}
            echo "send" >> ${file}
            echo "zone ${rzn}" >> ${file} 
            echo "update delete ${rv}. PTR ${2}.${domain}." >> ${file}
            echo "send" >> ${file}
            if [ ${1} -eq 1 ]; then
                echo "zone ${domain}" >> ${file}     
                echo "update add ${2}.${domain} 86400 A ${3}" >> ${file}
                echo "send" >> ${file}
                echo "zone ${rzn}" >> ${file}
                echo "update add ${rv}. 86400 PTR ${2}.${domain}." >> ${file}
                echo "send" >> ${file}
            fi
        fi
        shift 3
        let cnt=${cnt}-3
    done
    key=$(cat /etc/dhcp/ddns.key  | grep key | awk '{print $2}')
    sec=$(cat /etc/dhcp/ddns.key  | grep secret | awk -F\" '{print $2}')
    /usr/bin/nsupdate -y "${key}:${sec}" ${file}
}
 
do_vrules()
{
 
    base="/etc/shorewall"
    rules="${base}/rules"
    cnt=$#
    prefix=${1}
    shift 1
    nip=$(ip addr show $( grep NET_IF ${base}/interfaces | grep -o '[^=]*$') | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)
    if [ ${cnt} -gt 9 ]; then
        cp ${base}/bridge/rules ${rules}
        rm -f ${base}/macro.*
        echo "# BRIDGE USER RULES" >> ${rules}
        while true
        do
            if [ ${cnt} -le 9 ]; then break; fi
            if [ ${2} -eq 0 ] && [ "${4}" != "0" ]; then
                if [ ${1} -eq 0 ]; then st="#"; else st=""; fi
                if [ ${9} -gt 0 ]; then proto=${9}; else proto=${6}; fi
                if [ "${nip}" = "${7}" ]; then dest="\$FW"; else dest="loc"; fi
                echo -e ${st}${prefix}${4}\(DNAT\)'\t'"net"'\t'"${dest}:${7}:${8}"'\t'${proto}'\t'${5}'\t'\# ${3} >> ${rules}
                echo 'PARAM		-	-	-	-	-' > "${base}/macro.${prefix}${4}"
            fi
            shift 9
            let cnt=${cnt}-9
        done
    fi
}

do_ddns()
{
    shift 1

    enable=${1}
    domain=${2}
    account=${3}
    password=${4}
    provider=${5}
    lan_if=${6}

    file=/etc/ddclient.conf

    case ${provider} in
        0)
            proto="dyndns2"
            options="use=web, web=checkip.dyndns.com, web-skip='IP Address'"
            server="members.dyndns.org"
        ;;
        1)
            proto="easydns"
            options="use=if, if=${lan_if}"
            server="members.easydns.com"
        ;;
        2)
            proto="dslreports"
            options="use=if, if=${lan_if}"
            server="www.dslreports.com"
        ;;
        3)
            proto="zoneedit1"
            options="use=if, if=${lan_if}"
            server="dynamic.zoneedit.com"
        ;;
    esac
        
cat <<End-of-message>${file}
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# provider=${provider}
###############################################################################
protocol=${proto}                                                                
${options}                          
server=${server}                                                       
login=${account}                                                                 
password='${password}'                                                            
${domain} 
End-of-message

    if [ ${enable} -eq 0 ]; then
        /usr/sbin/service ddclient stop
        sleep 3
        if [ -f /var/run/ddclient.pid ]; then
            kill -TERM `cat /var/run/ddclient.pid`
            rm -f /var/run/ddclient.pid
            /usr/sbin/update-rc.d ddclient disable
        fi
    else
        /usr/sbin/update-rc.d ddclient enable
        /usr/sbin/service ddclient restart 
    fi

}

do_vpn()
{

    shift 1

    if=${1}
    network=${2}
    ns1=${3}
    enable=${6}
    how=${12}
    nconn=${13}

    
    case ${how} in
        [0-1])
            type="pptpd"
            file1="/etc/pptpd.conf"
            file2="/etc/ppp/pptpd-options"
            file3="/etc/ppp/ip-up.d/100forwarding"
            file4="/etc/ppp/ip-down.d/100forwarding"
            file5="/etc/ppp/chap-secrets"
            let nconn=${nconn}+2
            if [ ${how} -eq 1 ]; then enc="require-mppe-128"; fi
        ;;
        *)
            return
        ;;
    esac

cat <<End-of-message>${file1}
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
option /etc/ppp/pptpd-options
logwtmp
bcrelay ${if}
localip ${network}.1
remoteip ${network}.2-${nconn}
End-of-message

cat <<End-of-message>${file2}
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# type=${how}
###############################################################################
name pptpd
refuse-pap
refuse-chap
refuse-mschap
require-mschap-v2
nodefaultroute
lock
nobsdcomp
ms-dns ${ns1}
ms-dns 8.8.4.4
noipx
mtu 1490
mru 1490
lcp-echo-adaptive
lcp-echo-failure 3
lcp-echo-interval 600
noipv6
${enc}
End-of-message

cat <<End-of-message>${file3}
#!/bin/sh
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
NET="\`echo \${PPP_LOCAL} | cut -d. -f1-3\`.0/24"
LIF=\`/sbin/ip route | awk '/default/ {print \$NF}'\`
COMMENT="VPN_PPP_\${PPP_IFACE}"
/sbin/iptables -t nat -m comment --comment "\${COMMENT}" -A POSTROUTING -s \${NET} -o \${LIF} -j MASQUERADE
/sbin/iptables -I FORWARD -m comment --comment "\${COMMENT}" -p tcp --tcp-flags SYN,RST SYN -i \${PPP_IFACE} -j TCPMSS --set-mss 1356
exit 0
End-of-message

cat <<End-of-message>${file4}
#!/bin/sh
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
COMMENT="VPN_PPP_\${PPP_IFACE}"
/sbin/iptables-save | grep -v "\${COMMENT}" | iptables-restore
exit 0
End-of-message

cat <<End-of-message>${file5}
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
# Secrets for authentication using CHAP
# client	server	secret		IP addresses
End-of-message

    shift 13

    cnt=$#
    while true
    do
        if [ ${cnt} -le 0 ]; then break; fi
        let cnt=${cnt}-3
        if [ ${3} -eq 0 ]; then continue; fi
        echo "${1}	*	${2}	*" >> ${file5}
        shift 3      
    done

    chmod 754 ${file3} ${file4}

    if [ ${enable} -eq 0 ]; then
        /usr/sbin/service pptpd stop
        /usr/sbin/update-rc.d pptpd disable
    else
        /usr/sbin/update-rc.d pptpd enable
        /usr/sbin/service pptpd restart 
    fi

}

do_firewall_masqif()
{

    wan=${2}
    lan=${3}
    mask=$(/sbin/ifconfig ${lan} | grep -i netmask | awk -F' ' '{print $4}')
    ip=$(ip addr show eth0 | grep -v secondary | awk -F/ '/inet /{ print $1 }' | awk '{ print $NF }')
    net=$(ipcalc -b ${ip} ${mask} | grep Network: | awk '{print $2 }')

    if [ -f /etc/shorewall/tunnels ]; then
       vpnif="loc	ppp+"
    fi

    if [ "${4}" != "0" ]; then
        srvif=${4}
        srvip=${5}
        srvnet=$(ipcalc -b ${srvip} 255.255.255.0 | grep Network: | awk '{print $2 }')
    fi

    
    file=/etc/shorewall/interfaces

cat <<End-of-message>${file}
# Shorewall version 5.1 - Interface file for two-interface configuration.
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
?FORMAT 2
###############################################################################
#ZONE   INTERFACE       OPTIONS
net	NET_IF 		dhcp,tcpflags,nosmurfs,routefilter,logmartians=0,sourceroute=0,physical=${wan}
loc	LOC_IF		dhcp,tcpflags,nosmurfs,routefilter,logmartians=0,physical=${lan}
${vpnif}
End-of-message

    if [ -n "${srvif}" ]; then
        grep -q ${srvif} ${file}
        if [ $? -ne 0 ]; then
            echo "loc	${srvif}" >>${file}
        else
            unset srvnet
        fi
    fi

    file=/etc/shorewall/snat

cat <<End-of-message>${file}
# Shorewall version 5.1 - Snat file for two-interface configuration.
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
#ACTION		SOURCE		DEST
MASQUERADE	${net}	${wan}
End-of-message

    if [ -n "${srvnet}" ]; then
        echo "SNAT(${srvip})	${srvnet}	${srvif}:srv" >> ${file}
    fi

}

do_firewall_ts()
{
    file=/etc/shorewall/tcinterfaces
    if [ ${2} -eq 0 ]; then rm -f ${file}; return; fi

cat <<End-of-message>${file}
# Shorewall version 5.1 - Traffic shaping file
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
#INTERFACE	TYPE		IN-BANDWIDTH	OUT-BANDWIDTH
${5}		-		${3}mbit			${4}mbit
End-of-message
 
}

do_firewall_fws()
{

    shift 1

    base="/etc/shorewall"
    rules="${base}/rules"

    cp ${base}/bridge/rules /tmp/rules

    if [ ${1} -eq 1 ]; then
        echo "SSH(ACCEPT)		loc	\$FW" >> /tmp/rules
    else
        echo "SSH(REJECT)		loc	\$FW" >> /tmp/rules
    fi

    if [ ${2} -eq 1 ]; then                         
        echo "ACCEPT			loc	\$FW	udp	111	# portmap" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	tcp	111	# portmap" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	udp	2049	# nfs" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	tcp	2049	# nfs" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	tcp	32764:32769	# nfs dyn-ports" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	udp	32764:32769	# nfs dyn-ports" >> /tmp/rules
    else
        echo "REJECT			loc	\$FW	udp	111	# portmap" >> /tmp/rules
        echo "REJECT			loc	\$FW	tcp	111	# portmap" >> /tmp/rules
        echo "REJECT			loc	\$FW	udp	2049	# nfs" >> /tmp/rules
        echo "REJECT			loc	\$FW	tcp	2049	# nfs" >> /tmp/rules
        echo "REJECT			loc	\$FW	tcp	32764:32769	# nfs dyn-ports" >> /tmp/rules
        echo "REJECT			loc	\$FW	udp	32764:32769	# nfs dyn-ports" >> /tmp/rules
    fi

    if [ ${3} -eq 1 ]; then
        echo "ACCEPT			net	\$FW	tcp	1723	# VPN (pptpd)" >> /tmp/rules

        echo "# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN" > ${base}/tunnels
        echo "#TYPE		ZONE	GATEWAY		GATEWAY ZONE" >> ${base}/tunnels
        echo "pptpserver      loc              0.0.0.0/0" >> ${base}/tunnels
        grep -q "ppp+" ${base}/interfaces
        if [ $? -gt 0 ]; then
            echo "loc	ppp+" >> ${base}/interfaces
        fi

    else
        rm -f ${base}/tunnels
    fi

    echo "# BRIDGE USER RULES" >> /tmp/rules

    r=$(ls ${base}/macro.* | cut -d. -f2)

    for ar in ${r}
    do
        grep -m1 ${ar} ${rules} >> /tmp/rules
    done
    cp /tmp/rules ${rules}
}

do_cifs_disk()
{
    shift 2

    #/dev/sda1 1000GB ext4 9abae530-08e7-11e4-b529-5f1874a9b93e 2 0 HEDMANSHOME utf8 panda-drop N/A N/A 0 0

    fstype=${3}
    uuid=${4}
    action=${5}

    ext="bridge"
    mkdir -p /media/${ext}

    case ${action} in
        3)
            max=$(parted ${1} unit s print free | grep 'Free Space' | tail -n 1 | awk -Fs '{print $2}')
            #start=$(parted ${1} unit s print free | grep 'Free Space' | tail -n 1 | awk -Fs '{print $1}')
            start=2048
            end=$(echo "${max}*${2}" | bc | awk '{print int($1-0.5)}')
            
            parted -s -a optimal ${1} unit s mkpart primary ${3} ${start}s ${end}s
            $SHELL -c "nohup mkfs.${3} ${1}1 -U ${4} >/tmp/mkfs.${3}"
        ;;
        4)
            /usr/sbin/service samba stop
            sync;sync;sync
            umount /media/${ext}/${uuid}
            sleep 2
            grep -q /media/${ext}/${uuid} /proc/mounts
            if [ $? -eq 0 ]; then return; fi
            rm -rf /media/${ext}/*
            osize=$(wc -l /etc/fstab | awk '{ print $1 }')
            grep -v "${uuid}" /etc/fstab > /tmp/fstab
            let nsize=$(wc -l /tmp/fstab | awk '{ print $1 }')+1
            if [ ${osize} -eq ${nsize} ]; then
                cp /tmp/fstab /etc/fstab
            fi
            return          
        ;;
    esac


    curdisk=$(ls /media/${ext})
    if [ -n "${curdisk}" ]; then
        grep -q ${curdisk} /etc/fstab
        if [ $? -ne 0 ]; then
            rm -rf /media/${ext}/*
            curdisk=""
        fi
    fi
 
    cp /etc/fstab /tmp/fstab.orig
    rm -f /tmp/fstab
    ismount=1

    if [ "${curdisk}" != "${uuid}" ]; then
        if [ -n "${curdisk}" ]; then
            grep -q /media/${ext}/${curdisk} /proc/mounts
            ismount=$?
            umount /media/${ext}/${curdisk} 2> /dev/null
            sleep 2
            grep -q /media/${ext}/${curdisk} /proc/mounts
            if [ $? -eq 0 ]; then return; fi
            rm -rf /media/${ext}/*
        fi
        osize=$(wc -l /etc/fstab | awk '{ print $1 }')
        if [ -n "${curdisk}" ]; then
            grep -v "${curdisk}" /etc/fstab > /tmp/fstab
        else
            cp /etc/fstab /tmp/fstab
        fi
        echo "UUID=${uuid} /media/${ext}/${uuid}  ${fstype}  defaults,noatime  0  0" >> /tmp/fstab
        nsize=$(wc -l /tmp/fstab | awk '{ print $1 }')

        if [ -n  "${curdisk}" ]; then
            if [ ${osize} -ne ${nsize} ]; then return; fi
        else
            let osize=${osize}+1
            if [ ${osize} -ne ${nsize} ]; then return; fi
        fi
        cp /tmp/fstab /etc/fstab
        mkdir -m 775 -p /media/${ext}/${uuid}
        mount /media/${ext}/${uuid}
        grep -q /media/${ext}/${uuid} /proc/mounts
        if [ $? -ne 0 ]; then
            rmdir /media/${ext}/${uuid}
            cp /tmp/fstab.orig /etc/fstab
            mkdir -p -m 775 /media/${ext}/${curdisk}
            if [ ${ismount} -eq 0 ]; then
                mount /media/${ext}/${curdisk}
            fi
            return
        fi
        mkdir -m 775 -p /media/${ext}/${uuid}/${uuid}
    fi

    /usr/sbin/service samba restart
}

do_cifs()
{
    shift 7

    uuid=${1}
    workg=${2}
    chars=${3}

    file=/etc/samba/smb.conf

cat <<End-of-message>${file}
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
[global]

unix charset = ${chars}
workgroup = ${workg}
dns proxy = no
log file = /var/log/samba/log.%m
max log size = 1000
syslog = 0
security = share
passdb backend = tdbsam
obey pam restrictions = yes
domain master = auto
encrypt passwords = true
unix password sync = yes
passwd program = /usr/bin/passwd %u
passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully*
pam password change = yes
map to guest = bad user
hide dot files = yes

End-of-message

    shift 3

    ext="bridge"
    root="/media/${ext}/${uuid}/${uuid}"
    cnt=$#
    while true
    do
        if [ ${cnt} -le 0 ]; then break; fi
        let cnt=${cnt}-5

        if [ ${5} -eq 3 ]; then
            if [ ${4} -eq 1 ]; then
                smbpasswd -x ${2}
                userdel ${2}
            fi
            continue
        fi
        
        echo "[${1}]" >> ${file}
        if [ ${4} -eq 1 ]; then
            echo "    valid users = ${2}" >> ${file}
        else
            echo "    guest ok = yes" >> ${file}
        fi
        echo "    path = ${root}/${1}" >> ${file}
        echo "    writeable = yes" >> ${file}
        if [ ${4} -eq 1 ]; then
            echo "    read only = no" >> ${file}
            echo "    guest ok = no" >> ${file}
            echo "    create  mask = 0640" >> ${file}
            echo "    directory mask = 0750" >> ${file}
            echo "    comment = ${2}'s private folder" >> ${file}
            mkdir -m 0750 -p ${root}/${1}
            if [ ${5} -eq 1 ]; then
                $SHELL -c "useradd ${2} -p ${3} -M -s /bin/false"
                echo -ne "${3}\n${3}\n" | smbpasswd -a -s ${2}
            fi
            chown ${2}:${2} ${root}/${1}
        else
            echo "    browseable = yes" >> ${file}
            echo "    guest only = yes" >> ${file}
            echo "    create  mask = 0644" >> ${file}
            echo "    directory mask = 0755" >> ${file}
            echo "    comment = ${1} - a public folder" >> ${file}
            mkdir -m 0777 -p ${root}/${1}
        fi
        echo "" >> ${file}
        shift 5      
    done

    /usr/sbin/service samba restart

}

do_transmission()
{
    enab=${1}
    if [ ${2} -eq 1 ]; then auth="true"; else auth="false"; fi
    port=${3}
    dlp="${4}/transmission"
    user=${5}
    pw=${6}

    mkdir -p ${dlp}
    chmod 0777 ${dlp}

file=/var/lib/transmission-daemon/info/settings.json

cat <<End-of-message>${file}
{
    "alt-speed-down": 50, 
    "alt-speed-enabled": false, 
    "alt-speed-time-begin": 540, 
    "alt-speed-time-day": 127, 
    "alt-speed-time-enabled": false, 
    "alt-speed-time-end": 1020, 
    "alt-speed-up": 50, 
    "bind-address-ipv4": "0.0.0.0", 
    "bind-address-ipv6": "::", 
    "blocklist-enabled": false, 
    "blocklist-url": "http://www.example.com/blocklist", 
    "cache-size-mb": 4, 
    "dht-enabled": true, 
    "download-dir": "${dlp}", 
    "download-limit": 100, 
    "download-limit-enabled": 0, 
    "download-queue-enabled": true, 
    "download-queue-size": 5, 
    "encryption": 1, 
    "idle-seeding-limit": 30, 
    "idle-seeding-limit-enabled": false, 
    "incomplete-dir": "/root/Downloads", 
    "incomplete-dir-enabled": false, 
    "lpd-enabled": false, 
    "max-peers-global": 200, 
    "message-level": 2, 
    "peer-congestion-algorithm": "", 
    "peer-limit-global": 240, 
    "peer-limit-per-torrent": 60, 
    "peer-port": 51413, 
    "peer-port-random-high": 65535, 
    "peer-port-random-low": 49152, 
    "peer-port-random-on-start": false, 
    "peer-socket-tos": "default", 
    "pex-enabled": true, 
    "port-forwarding-enabled": false, 
    "preallocation": 1, 
    "prefetch-enabled": 1, 
    "queue-stalled-enabled": true, 
    "queue-stalled-minutes": 30, 
    "ratio-limit": 2, 
    "ratio-limit-enabled": false, 
    "rename-partial-files": true, 
    "rpc-authentication-required": ${auth}, 
    "rpc-bind-address": "0.0.0.0", 
    "rpc-enabled": true, 
    "rpc-password": "${pw}", 
    "rpc-port": ${port}, 
    "rpc-url": "/transmission/", 
    "rpc-username": "${user}", 
    "rpc-whitelist": "127.0.0.1", 
    "rpc-whitelist-enabled": false, 
    "scrape-paused-torrents-enabled": true, 
    "script-torrent-done-enabled": false, 
    "script-torrent-done-filename": "", 
    "seed-queue-enabled": false, 
    "seed-queue-size": 10, 
    "speed-limit-down": 100, 
    "speed-limit-down-enabled": false, 
    "speed-limit-up": 100, 
    "speed-limit-up-enabled": false, 
    "start-added-torrents": true, 
    "trash-original-torrent-files": false, 
    "umask": 18, 
    "upload-limit": 100, 
    "upload-limit-enabled": 0, 
    "upload-slots-per-torrent": 14, 
    "utp-enabled": true
}
End-of-message

    grep -v "transmission on fw" /etc/shorewall/rules > /tmp/rules
    if [ -s /tmp/rules ]; then
        cp /tmp/rules /etc/shorewall/rules
        rm -f /tmp/rules*
    fi
    grep -v "transmission on fw" /etc/shorewall/bridge/rules > /tmp/rules
    if [ -s /tmp/rules ]; then
        cp /tmp/rules /etc/shorewall/bridge/rules
        rm -f /tmp/rules*
    fi

    if [ ${enab} -eq 1 ]; then
        sed "8aACCEPT			loc	\$FW 	tcp	${port}	# transmission on fw" /etc/shorewall/rules > /tmp/rules.tmp
        sed "9aACCEPT			net	\$FW 	tcp	${port}	# transmission on fw" /tmp/rules.tmp  > /tmp/rules
        if [ -s /tmp/rules ]; then
            cp /tmp/rules /etc/shorewall/rules
            rm -f /tmp/rules*
        fi
        sed "11aACCEPT			loc	\$FW 	tcp	${port}	# transmission on fw" /etc/shorewall/bridge/rules > /tmp/rules.tmp
        sed "12aACCEPT			net	\$FW 	tcp	${port}	# transmission on fw" /tmp/rules.tmp  > /tmp/rules
        if [ -s /tmp/rules ]; then
            cp /tmp/rules /etc/shorewall/bridge/rules
        fi
    fi
    rm -f /tmp/rules*

}

do_fwlog()
{
    shift 2
    if [ ${1} -eq 1 ]; then dlog="\$LOG_LEVEL"; else dlog=""; fi
    if [ ${2} -eq 1 ]; then rlog="\$LOG_LEVEL"; else rlog=""; fi

    file=/etc/shorewall/policy

cat <<End-of-message>${file}
# Shorewall version 5.1 - Policy file
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
#SOURCE		DEST		POLICY		LOG LEVEL	RATE	CONNLIMIT
\$FW        	net		ACCEPT
loc		net		ACCEPT
net		all		DROP		$dlog
# THE FOLLOWING POLICY MUST BE LAST
all		all		REJECT		$rlog
End-of-message

}
