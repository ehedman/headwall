#!/bin/bash
# Author: Erland@Hedmanshome.se

# shellcheck disable=SC2129

p_uptime()
{
   uptime=$(</proc/uptime)
   uptime=${uptime%%.*}

   #seconds=$(( uptime%60 ))
   minutes=$(( uptime/60%60 ))
   hours=$(( uptime/60/60%24 ))
   days=$(( uptime/60/60/24 ))

   echo -n  "$days days, $hours hours, $minutes minutes"
}

doMkKey()
(
    if [ -s /etc/dhcp/ddns.key ] && [ -s /etc/bind/rndc.key ]; then
       return
    fi

    cd /tmp || return

    key=$(tsig-keygen -a HMAC-MD5 DDNS_UPDATE |  awk '/secret/ {print $2}')

cat <<End-of-message>/etc/dhcp/ddns.key
key DDNS_UPDATE {
    algorithm HMAC-MD5.SIG-ALG.REG.INT;
    secret ${key}
};
End-of-message

cat <<End-of-message>/etc/bind/rndc.key
key "rndc-key" {
        algorithm hmac-md5;
        secret ${key}
};
End-of-message

    cd -  >/dev/null 2>&1 || return
)

do_nlist()
{
    if=$3
    nw=$(ifconfig "${if}" | grep -m1 inet | awk '{printf $2}' | cut -d. -f1-3)

    if [ -z "${nw}" ]; then
        echo "" > /tmp/hostopts
        return
    fi

    nbtscan -e "${nw}".1-253 | awk '{printf "<option value=%s%s%s>%s</option>","\"",$1,"\"",tolower($2)}' >/tmp/hostopts &
}

do_hlist()
{
    dm=$2
    if [ -z "${dm}" ]; then
        dm=$(grep search /etc/resolv.conf | awk '{print $2}')
        if [ -z "${dm}" ]; then return; fi
    fi
    host -W 2 -l "${dm}" 127.0.0.1 | awk 'NR>6{gsub(".'"${dm}"'", "");printf "<option value=%s%s%s>%s</option>","\"",$4,"\"",$1}' >/tmp/hostopts &

}

do_hostopts()
{
    if pidof -s -q named; then
        do_hlist "$@"
    else
        do_nlist "$@"
    fi
}

do_wifilist()
{
    ifs=$(find /sys/devices/platform -name phy80211 | awk -F/ '{printf $(NF - 1) "\n"}' | sort | awk '{printf $(NF) " "}')
    if [ -n "${ifs}" ]; then
        echo -n "["
        for if in ${ifs}; do
            echo -n '"'"${if}"'", '
        done
        echo -n '"0"]'
    else
t           echo -n '["0"]'
    fi
}

do_ifopts()
{
    devs=$(grep : /proc/net/dev | cut -d: -f1 | grep -v lo | awk '{printf "%s ", $NF}')

    for dev in $devs
    do
        echo -n "<option value='$dev'"
        if [ "$2" = "$dev" ]; then echo -n " selected='selected'"; fi
        echo -n ">$dev</option>"
    done
}

do_wifopts()
{
    devs=$(find /sys/devices/platform -name phy80211 | awk -F/ '{printf $(NF - 1) "\n"}' | sort | awk '{printf $(NF) " "}')

    for dev in $devs
    do
        echo -n "<option value='$dev'"
        if [ "$2" = "$dev" ]; then echo -n " selected='selected'"; fi
        echo -n ">$dev</option>"
    done
}

do_setstatic()
{
    cp /etc/network/interfaces /etc/network/interfaces.old
    shift 1

    search=${4}
    wan=${8}
    lan=${9}
    lan1_if=${10}
    srvif=${11}
    srvip=${12}

    if ! find /sys/devices/platform -name phy80211 | grep -q "${wan}"; then dis="#na"; fi

    cat <<End-of-message>/etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

# The loopback network interface
auto lo
iface lo inet loopback

allow-hotplug ${lan}
allow-hotplug ${wan}

auto ${wan}
iface ${wan} inet static
    address ${1}
    netmask ${2}
    gateway ${3}
$dis    wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
    post-up resolvconf -d \$IFACE
    post-up iptables -t nat -A POSTROUTING -o \$IFACE -j MASQUERADE
    post-up echo 1 > /proc/sys/net/ipv4/ip_forward
    post-down echo 0 > /proc/sys/net/ipv4/ip_forward
    dns-nameservers ${3}
    dns-search ${search}

auto ${lan}
iface ${lan} inet static
    address ${5}
    netmask ${6}
End-of-message

    echo "${4}" > /etc/hostname; hostname -F /etc/hostname
    
    swrestart=0

    if shorewall status | grep -q running; then
        /sbin/shorewall stop
        /sbin/shorewall clear
        swrestart=1
    fi

    newlan=$(md5sum /etc/network/interfaces | awk '{printf $1}')
    oldlan=$(md5sum /etc/network/interfaces.old | awk '{printf $1}')

    if [ "${oldlan}" != "${newlan}" ]; then
        /sbin/ifdown -a --force
        sleep 1
        /sbin/ifup -a --force
        sleep 1

        if pidof -s -q named; then             
            if grep -q 'redir_here=y' /etc/bind/null.zone.file; then
                rd=$(grep '\*' /etc/bind/null.zone.file | awk '{print $4}')
                /sbin/ifconfig "${lan1_if}" "${rd}" up
            fi
            /usr/bin/systemctl stop bind9
        fi

        dhif=$(grep interface /etc/dhcp/dhcpd.conf| awk -F\" '{printf "%s", $2}')
        if [ -n "${dhif}" ]; then
            sed /"${dhif}"/s//"${lan}"/g /etc/dhcp/dhcpd.conf > /tmp/dhif
            if [ -f /tmp/dhif ]; then
                mv /tmp/dhif /etc/dhcp/dhcpd.conf
                if pidof -s -q dhcpd; then
                    /usr/bin/systemctl stop isc-dhcp-server
                fi
            fi
        fi

        newlan=$(md5sum /etc/network/interfaces | awk '{printf $1}')
        oldlan=$(md5sum /etc/network/interfaces.old | awk '{printf $1}')

        if [ "${oldlan}" != "${newlan}" ]; then
            /usr/bin/systemctl stop bind9 isc-dhcp-server
            echo "" > /var/lib/dhcp*/dhcpd.leases
            rm -f /etc/bind/db*.jnl
        fi

        hapconf="/etc/hostapd/${lan}.conf"
        hapserv="hostapd@${lan}.service"

        if find /sys/devices/platform -name phy80211 | awk -F/ '{printf $(NF - 1) " "}' | grep -q "${lan}"; then
            haif=$(grep -m1 interface "${hapconf}" | awk -F= '{printf "%s", $2}')
            if [ -n "${haif}" ]; then
                sed /"${haif}"/s//"${lan}"/g "${hapconf}" > /tmp/haif
                if [ -f /tmp/haif ]; then
                    cp /tmp/haif  "${hapconf}"
                    /usr/bin/systemctl restart "${hapserv}"
                fi
            fi
        fi
    fi

    do_firewall_masqif na "${wan}" "${lan}" "${srvif}" "${srvip}"

    if [ -f /etc/shorewall/tcinterfaces ]; then
        data=$(grep mbit /etc/shorewall/tcinterfaces | awk '{printf "%s %s\n", $3,$4}' | sed /mbit/s///g)
# shellcheck disable=SC2086 # this is intentional
        do_firewall_ts na 1 ${wan} "${data}" 
    fi

    if (( "$swrestart" == 1 )); then
        /sbin/shorewall start
    fi
}

do_setdhcp()
{

    cp /etc/network/interfaces /etc/network/interfaces.old
    shift 1

    search=${1}
    wan=${5}
    lan=${6}
    lan1_if=${7}
    srvif=${8}
    srvip=${9}

    if ! find /sys/devices/platform -name phy80211 | grep -q "${wan}"; then dis="#na"; fi

    cat <<End-of-message>/etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

# The loopback network interface
auto lo
iface lo inet loopback

allow-hotplug ${lan}
allow-hotplug ${wan}

auto ${wan}
iface ${wan} inet dhcp 
$dis    wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf
    post-up resolvconf -d \$IFACE
    post-up iptables -t nat -A POSTROUTING -o \$IFACE -j MASQUERADE
    post-up echo 1 > /proc/sys/net/ipv4/ip_forward
    post-down echo 0 > /proc/sys/net/ipv4/ip_forward
    dns-nameservers ${2}
    dns-search ${search}

auto ${lan}
iface ${lan} inet static
    address ${2}
    netmask ${3}
End-of-message

    echo "${1}" > /etc/hostname; hostname -F /etc/hostname

    newlan=$(md5sum /etc/network/interfaces | awk '{printf $1}')
    oldlan=$(md5sum /etc/network/interfaces.old | awk '{printf $1}')

    if [ "${oldlan}" != "${newlan}" ]; then
        /sbin/ifdown -a --force
        sleep 1
        /sbin/ifup -a --force
        sleep 1

        if pidof -s -q named; then             
            if grep -q 'redir_here=y' /etc/bind/null.zone.file; then
                rd=$(grep '\*' /etc/bind/null.zone.file | awk '{print $4}')
                /sbin/ifconfig "${lan1_if}" "${rd}" up
            fi
            /usr/bin/systemctl stop bind9
        fi

        dhif=$(grep -m1 interface /etc/dhcp/dhcpd.conf | awk -F\" '{printf "%s", $2}')
        if [ -n "${dhif}" ]; then
            sed /"${dhif}"/s//"${lan}"/g /etc/dhcp/dhcpd.conf > /tmp/dhif
            if [ -f /tmp/dhif ]; then
                mv /tmp/dhif /etc/dhcp/dhcpd.conf 
                if pidof -s -q dhcpd; then
                    /usr/bin/systemctl stop isc-dhcp-server
                fi
            fi
        fi

        /usr/bin/systemctl stop bind9 isc-dhcp-server
        echo "" > /var/lib/dhcp*/dhcpd.leases
        rm -f /etc/bind/db*.jnl

        hapconf="/etc/hostapd/${lan}.conf"
        hapserv="hostapd@${lan}.service"

        if find /sys/devices/platform -name phy80211 | awk -F/ '{printf $(NF - 1) " "}' | grep -q "${lan}"; then
            haif=$(grep -m1 interface "${hapconf}" | awk -F= '{printf "%s", $2}')
            if [ -n "${haif}" ]; then
                sed /"${haif}"/s//"${lan}"/g "${hapconf}" > /tmp/haif
                if [ -f /tmp/haif ]; then
                    mv /tmp/haif  "${hapconf}"
                    /usr/bin/systemctl restart "${hapserv}"
                fi
            fi
        fi
 
    fi

    do_firewall_masqif na "${wan}" "${lan}" "${srvif}" "${srvip}"

    if [ -f /etc/shorewall/tcinterfaces ]; then
        data=$(grep mbit /etc/shorewall/tcinterfaces | awk '{printf "%s %s\n", $3,$4}' | sed /mbit/s///g)
# shellcheck disable=SC2086 # this is intentional
        do_firewall_ts na 1  ${data} "${wan}"
    fi

     if shorewall status | grep -q running; then
        /sbin/shorewall restart
    fi

}

do_hostapd()
{
    wpa=${1}
    if=${2}
    ssid=${3}
    pp=${4}
    cip=${5}
    cha=${6}
    mode=${7}
    cou=${8}
    visi=${9}

    if [ "${mode}" == "a" ] || [ "${mode}" == "g" ]; then
        m11n="1"
    else
        m11n="0" 
    fi
    if (( "${cha}" >= 32 )); then
        cat <<End-of-message>/etc/hostapd/"${if}".conf
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# 5Ghz band
interface=${if}
driver=nl80211
country_code=${cou}
ctrl_interface=/var/run/hostapd
ctrl_interface_group=0
ssid=${ssid}
hw_mode=${mode}
channel=${cha}
wpa=${wpa}
wpa_passphrase=${pp}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=${cip}
rsn_pairwise=CCMP
auth_algs=3
macaddr_acl=0
logger_syslog=-1
logger_syslog_level=2
logger_stdout=-1
logger_stdout_level=2
wmm_enabled=1
ieee80211n=${m11n}
ignore_broadcast_ssid=${visi}
# N
ieee80211n=1
require_ht=1
ht_capab=[MAX-AMSDU-3839][HT40+][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40]
# AC
ieee80211ac=1
require_vht=1
ieee80211d=0
ieee80211h=0
vht_capab=[MAX-AMSDU-3839][SHORT-GI-80]
vht_oper_chwidth=1
vht_oper_centr_freq_seg0_idx=42
End-of-message

else
        cat <<End-of-message>/etc/hostapd/"${if}".conf
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# 2.4Ghz band
interface=${if}
driver=nl80211
country_code=${cou}
ctrl_interface=/var/run/hostapd
ctrl_interface_group=0
ssid=${ssid}
hw_mode=g
channel=${cha}
wpa=${wpa}
wpa_passphrase=${pp}
wpa_key_mgmt=WPA-PSK
wpa_pairwise=${cip}
rsn_pairwise=CCMP
auth_algs=3
macaddr_acl=0
wmm_enabled=1
ignore_broadcast_ssid=${visi}
ieee80211n=1
ieee80211ac=1
ht_capab=[HT30][SHORT-GI-30]
#ht_capab=[HT40][SHORT-GI-20][SHORT-GI-40]
End-of-message
fi

/usr/bin/systemctl restart hostapd@"${if}"

}

udec=""
urldecode()
{                                                                               
    local url_encoded="${1//+/ }"
    udec=$(printf '%b' "${url_encoded//%/\x}")
} 

do_setwep()
{
    /sbin/ifdown --force "${3}"
   
    urldecode "${1}"
    cat <<End-of-message>/etc/wpa_supplicant/wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
        ssid="${udec}"
        key_mgmt=NONE
        wep_key0="${2}"
        wep_tx_keyidx=0
} 
End-of-message
    /sbin/ifup "${3}" >/dev/null 2>&1; sleep 2;
}

do_setwpapsk()
{
    /sbin/ifdown --force "${5}"
    # WPA2 bukefalos 090e0b0c0d 2 wlan0

    urldecode "${2}"

    if [ "${1}" = "WPA2" ]; then proto="RSN"; else proto="WPA"; fi
    if (( "${4}" == 2 )); then cipher="TKIP"; fi
    if (( "${4}" == 3 )); then
        if [ "${1}" = "WPA2" ];
            then cipher=""
        fi
    fi

cat <<End-of-message>/etc/wpa_supplicant/wpa_supplicant.conf
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
network={
        ssid="${udec}"
        proto=${proto}
        key_mgmt=WPA-PSK
        pairwise=CCMP ${cipher}
        group=CCMP ${cipher}
        psk="${3}"
} 
End-of-message
    /sbin/ifup "${5}" >/dev/null 2>&1; sleep 2;
}

do_dhcpd()
{
    doMkKey

    if (( "${3}" == 1 )); then server=true; else server=false; fi
    shift 3

    lan_ip=${1}
    lan_mask=${2}
    domain=${7}
#    wan_if=${11}
    lan_if=${12}
    lan1_if=${13}
   
    if (( "${10}" == 1 )); then
        relay="# dns-relay true" 
        resolv=$(grep -m1 nameserver /etc/resolv.conf | awk '{printf "%s", $2}')
        r2=$(grep nameserver /etc/resolv.conf | awk '{printf "%s ", $2}' | awk '{print $2}')
        if [ -n "${r2}" ]; then
            resolv="${resolv}, ${r2}"
        fi
    else
        relay="#"
        resolv="${8}"
        if [ -n "${9}" ]; then
            resolv="${8}, ${9}"
        fi
    fi  

    swrestart=0

    sub=$(ipcalc -b "${lan_ip}" "${lan_mask}" | grep Network: | awk '{print $2 }' | cut -d/ -f1)
    broadc=$(ipcalc "${sub}"/"${lan_mask}" | grep Broadcast | awk '{print $2}')
    iprev=$(echo "${sub}" | sed s/"\."/" "/g | awk '{print $3"."$2"."$1}')

    rzone="${iprev}.in-addr.arpa"
    filedns="/tmp/dnsbatch-1.txt"

    extrainc=""
    extraif=""
    if [ -f /etc/dhcp/extra.conf ]; then
        # include subnet declarations outside the config scoop of this app
        extraif=$(grep  interface /etc/dhcp/extra.conf | awk -F\" '{print $2}')
        if [ -n "${extraif}" ]; then
            extrainc=$(cat /etc/dhcp/extra.conf)
        fi
    fi

    if [ ${server} = true ]; then
        file="/etc/dhcp/dhcpd.conf"
        grep -v INTERFACESv4 /etc/default/isc-dhcp-server > /tmp/isc-dhcpd.tmp
        if [ -n "${extraif}" ]; then
            if="${lan_if} ${extraif}"
        else
            if="${lan_if}"
        fi
        echo "INTERFACESv4=\"${if}\"" >>  /tmp/isc-dhcpd.tmp
        mv /tmp/isc-dhcpd.tmp /etc/default/isc-dhcp-server
    else
        file=/dev/null
    fi

cat <<End-of-message>${file}
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
${relay}
ddns-update-style       interim;
ignore                  client-updates;
update-static-leases    on;

authoritative;

include "/etc/dhcp/ddns.key";

zone ${domain}. {
  primary 127.0.0.1;
  key "DDNS_UPDATE";
}

zone ${iprev}.in-addr.arpa. {
  primary 127.0.0.1;
  key "DDNS_UPDATE";
}

log-facility local7;
max-lease-time 86400;

subnet ${sub} netmask ${lan_mask} {
  interface "${lan_if}";
  range ${3} ${4};
  option domain-name "${domain}";
  option domain-name-servers ${resolv};
  option routers ${lan_ip};
  option broadcast-address ${broadc};
  default-lease-time ${5};
}
${extrainc}
End-of-message
    shift 13

# Fixed IP addresses

    echo "# Fixed IP addresses" >> ${file}
    echo "server ${lan_ip}" >${filedns}
    cnt=$#

    while true
    do
    if (( "${cnt}" <= 0 )); then break; fi
        rv=$(echo "${3}"|sed s/"\."/" "/g|awk '{printf "%s.%s.%s.%s.in-addr.arpa",$4,$3,$2,$1}')
        echo "zone ${domain}" >> "${filedns} "
        echo "update delete ${4}.${domain}" >> "${filedns}"
        echo "send" >> ${filedns}
        echo "zone ${rzone}" >> "${filedns} "
        echo "update delete ${rv}. PTR ${4}.${domain}." >> "${filedns}"
        echo "send" >> "${filedns} "      

        if (( ${1} == 3 )); then
            shift 4
            cnt=$(("${cnt}"-4))         
            continue;
        fi

        if (( "${1}" == 2 )) || (( "${1}" == 0 )); then
            rmadynlease "${2}" "${lan_if}"
        fi
        
        if (( "${1}" == 0 )); then d="#"; else d=""; fi

        echo "${d}host ${4}.${domain} {" >> "${file}"
        echo "${d}    hardware ethernet ${2};" >> "${file}"
        echo "${d}    fixed-address ${3};" >> "${file}"
        echo "${d}}" >> "${file}"

       if (( "${1}" == 1 )); then
            echo "zone ${domain}" >> "${filedns} "    
            echo "update add ${4}.${domain} 86400 A ${3}" >> "${filedns}"
            echo "send" >> "${filedns}"
            echo "zone ${rzone}" >> "${filedns}"
            echo "update add ${rv}. 86400 PTR ${4}.${domain}." >> "${filedns}"
            echo "send" >> "${filedns}"
        fi

        shift 4
        cnt=$(("${cnt}"-4))
    done

    cip=$(grep -m1 -A1 "iface ${lan_if} inet static" /etc/network/interfaces | grep address | awk '{print $2}')
    sed  /"${cip}"/s//"${lan_ip}"/ /etc/network/interfaces >/tmp/ifs
    
    if [ -s /tmp/ifs ]; then
        cp /etc/network/interfaces  /etc/network/interfaces.old
        mv /tmp/ifs /etc/network/interfaces
    fi
     
    if pidof -s -q named; then 
        key=$(grep key /etc/dhcp/ddns.key | awk '{print $2}')
        sec=$(grep secret /etc/dhcp/ddns.key | awk -F\" '{print $2}')
        /usr/bin/nsupdate -y "${key}:${sec}" "${filedns}"
    fi

    newlan=$(md5sum /etc/network/interfaces | awk '{printf $1}')
    oldlan=$(md5sum /etc/network/interfaces.old | awk '{printf $1}')

    if [ "${oldlan}" != "${newlan}" ]; then
       /sbin/ifdown -a --force
        sleep 1
        /sbin/ifup -a --force
        sleep 1

        
        if pidof -s -q named; then               
            if grep -q 'redir_here=y' /etc/bind/null.zone.file; then
                rd=$(grep '\*' /etc/bind/null.zone.file | awk '{print $4}')
                /sbin/ifconfig "${lan1_if}" "${rd}" up
            fi
        fi

        /usr/bin/systemctl stop bind9 isc-dhcp-server
        echo "" > /var/lib/dhcp*/dhcpd.leases
        rm -f /etc/bind/db*.jnl

    fi

    if (( "$swrestart" == 1 )); then
        /sbin/shorewall restart
    fi
}

do_updatedhcp()
{
    primary=${1}
    secondary=${2}

    file=/etc/dhcp/dhcpd.conf

    opattern="$(grep -m1 "option domain-name-servers" ${file})"

    if [ -n  "${secondary}" ]; then
        npattern="${primary}, ${secondary}"
    else
        npattern="${primary}"
    fi

    if pidof -s -q dhcpd; then
        sed "s/${opattern}/  option domain-name-servers ${npattern};/" "${file}" > /tmp/udhcp
        if [ -s /tmp/udhcp ]; then
            cp /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.old
            cp /tmp/udhcp /etc/dhcp/dhcpd.conf
            if ! diff --ignore-blank-lines /etc/dhcp/dhcpd.conf /etc/dhcp/dhcpd.conf.old > /dev/null; then
                /usr/bin/systemctl restart isc-dhcp-server
            fi
        fi
    fi
    rm -f /tmp/udhcp
}

do_rangecheck()
{
    dip=${1}
    mask=${2}
    sip=${3}
    eip=${4}
    netw=$(ipcalc -b "${dip}" "${mask}" | grep Network: | awk '{print $2 }' | cut -d/ -f1)
    sipn=$(ipcalc -b "${sip}" "${mask}" | grep Network: | awk '{print $2 }' | cut -d/ -f1)
    eipn=$(ipcalc -b "${eip}" "${mask}" | grep Network: | awk '{print $2 }' | cut -d/ -f1)

    if [ "${sipn}" = "${netw}" ] &&  [ "${eipn}" = "${netw}" ]; then
        echo "" > /tmp/netrange
    else
        echo "${netw}" > /tmp/netrange
    fi
}

do_dbhome()
{
    doMkKey

    if (( "${3}" == 1 )); then dns_enable=true; else dns_enable=false; fi
    if (( "${4}" == 1 )); then bl_enable=true; else bl_enable=false; fi
#    if (( "${5}" == 1 )); then bl_updates=true; else bl_updates=false; fi
#    if (( "${6}" == 1 )); then gg_jumps=true; else gg_jumps=false; fi
    dnsfw_1=${7}
    dnsfw_2=${8}
    serving_net=${9}
    domain=${10}
    redir_spf=${11}
    spf_here=${12}
    lan_if=${13}
    lan1_if=${14}

    
    thishost=$(hostname)
    thisip=$(ifconfig "${lan_if}" | grep -m1 inet | awk '{printf $2}')

    file=/etc/bind/db.${domain}

cat <<End-of-message>"${file}"
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
\$TTL    604800
@       IN      SOA     ${thishost}.${domain}. root.${domain}. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@	IN	NS	${thishost}.${domain}.
\$ORIGIN ${domain}.
${thishost}	A	${thisip}
End-of-message

    shift 17

    cnt=$#
    while true
    do
    
    if (( "${cnt}" <= 0 )); then break; fi
        if (( "${1}" == 1 )); then
            echo -e "${2}"'\t'"A"'\t'"${3}">> "${file}"
        fi
        shift 3
        cnt=$(("${cnt}"-3))
    done
}

do_dbrev()
{
    doMkKey 

    if (( "${3}" == 1 )); then dns_enable=true; else dns_enable=false; fi
    if (( "${4}" == 1 )); then bl_enable=true; else bl_enable=false; fi
#    if (( "${5}" == 1 )); then bl_updates=true; else bl_updates=false; fi
#    if (( "${6}" == 1 )); then gg_jumps=true; else gg_jumps=false; fi

    dnsfw_1=${7}
    dnsfw_2=${8}
    serving_net=${9}
    domain=${10}
    redir_spf=${11}
    lan_if=${13}
    lan1_if=${14}

    if (( "${12}" == 1 )); then spf_here="redir_here=y"; else spf_here="redir_here=n"; fi

    shift 8

    thisip=$(ifconfig "${lan_if}" | grep -m1 inet | awk '{printf $2}')
    iprev=$(echo "${serving_net}" | sed s/"\."/" "/g | awk '{print $3"."$2"."$1}')
   
    thishost="$(hostname)"

    if [ "${bl_enable}" = true ]; then
        blist='include "/etc/bind/blacklist";'
    fi

    file=/etc/bind/db."${iprev}"

cat <<End-of-message>"${file}"
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
\$TTL    604800
@       IN      SOA     ${thishost}.${domain}. root.${domain}. (
                              2         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
@	IN	NS	${thishost}.
;
End-of-message

    shift 6
    cnt=$#
    while true
    do
    if (( "${cnt}" <= 0 )); then break; fi
        if (( "${1}" == 1 )); then
            tail=$(echo "${3}" | cut -d. -f4)
            echo -e "${tail}"'\t'"IN"'\t'"PTR"'\t'"${2}"."${domain}".>> "${file}"
        fi
        shift 3
        cnt=$(("${cnt}"-3))
    done

    file=/etc/bind/named.conf.local
cat <<End-of-message>"${file}"
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
include "/etc/bind/zones.rfc1918";
include "/etc/bind/rndc.key";
include "/etc/dhcp/ddns.key";
${blist}

controls {
        inet 127.0.0.1 allow { localhost; } keys { "DDNS_UPDATE"; };
};

zone "${domain}" {
        type master;
        file "/etc/bind/db.${domain}";
        allow-update { key "DDNS_UPDATE"; };
};

zone "${iprev}.in-addr.arpa" {
        type master;
        file "/etc/bind/db.${iprev}";
        allow-update { key "DDNS_UPDATE"; };
};
End-of-message

    file=/etc/bind/named.conf.options
cat <<End-of-message>"${file}"
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
options {
        directory "/var/cache/bind";
        managed-keys-directory "/var/named/dynamic";
        listen-on { 127.0.0.1; ${thisip}; };
        listen-on-v6 { none; };

        allow-recursion { any; };
        allow-query { any; };
        allow-query-cache { any; };

        forwarders {
                ${dnsfw_1};
                ${dnsfw_2};
                80.251.201.177;
                80.251.201.178;
        };
        
        dnssec-validation no;

        auth-nxdomain no;
};
End-of-message

    file=/etc/bind/null.zone.file
cat <<End-of-message>"${file}"
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
; ${spf_here}
\$TTL    86400   ; one day
        
@	IN		SOA		${thishost}.${domain}. root.${domain}. (
            2002061000       ; serial number YYMMDDNN
            28800   ; refresh  8 hours 
            7200    ; retry    2 hours
            864000  ; expire  10 days
            86400 ) ; min ttl  1 day
	NS      ${thishost}.${domain}
        
			A		${redir_spf}
;
@	IN		A		${redir_spf}
*	IN		A		${redir_spf}
End-of-message

    serving_net_in=$(echo "${serving_net}" | cut -d. -f1-2 | sed s/"\."/" "/| awk '{print $2"."$1}')

file=/etc/bind/zones.rfc1918
cat <<End-of-message>"${file}"
zone "10.in-addr.arpa"      { type master; file "/etc/bind/db.empty"; };
zone "16.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "17.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "18.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "19.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "20.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "21.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "22.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "23.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "24.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "25.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "26.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "27.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "28.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "29.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "30.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "31.172.in-addr.arpa"  { type master; file "/etc/bind/db.empty"; };
zone "${serving_net_in}.in-addr.arpa" { type master; file "/etc/bind/db.empty"; };
End-of-message

    chown bind:bind /etc/bind/*

    if [ ${dns_enable} = true ]; then
        /usr/bin/systemctl restart bind9
        if [ ${spf_here} = "redir_here=y" ]; then
            /sbin/ifconfig "${lan1_if}" "${redir_spf}" up
        else
            /sbin/ifconfig "${lan1_if}" down
        fi
    else
        /usr/bin/systemctl stop bind9
        /sbin/ifconfig "${lan1_if}" down
    fi 
}

do_updatedns()
{
    shift 1
    dnsfw_1=${1}
    dnsfw_2=${2}
    redir_spf=${3}
    domain=${5}
    serving_net=${7}
    lan_if=${8}
    lan1_if=${9}

    if (( "${4}" == 1 )); then spf_here="redir_here=y"; else spf_here="redir_here=n"; fi
    if (( "${6}" == 1 )); then bl_enable=true; else bl_enable=false; fi
    thisip=$(ifconfig "${lan_if}" | grep -m1 inet | awk '{printf $2}')
    thishost=$(hostname)
    if [ ${bl_enable} = true ]; then
        blist='include "/etc/bind/blacklist";'
    fi
    iprev=$(echo "${serving_net}" | sed s/"\."/" "/g | awk '{print $3"."$2"."$1}')

    if [ ${bl_enable} = true ] && [ "${4}" -eq 1 ]; then
        ifconfig "${lan1_if}" "${redir_spf}" up
    else
        ifconfig "${lan1_if}" down
    fi

    file=/etc/bind/named.conf.options
    cat <<End-of-message>${file}
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
options {
        directory "/var/cache/bind";
        managed-keys-directory "/var/named/dynamic";
        listen-on { 127.0.0.1; ${thisip}; };
        listen-on-v6 { none; };

        allow-recursion { any; };
        allow-query { any; };
        allow-query-cache { any; };

        forwarders {
                ${dnsfw_1};
                ${dnsfw_2};
                80.251.201.177;
                80.251.201.178;
        };

        dnssec-validation no;

        auth-nxdomain no;
};
End-of-message

    file=/etc/bind/null.zone.file
cat <<End-of-message>${file}
; DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
; ${spf_here}
\$TTL    86400   ; one day
        
@	IN		SOA		${thishost}.${domain}. root.${domain}. (
            2002061000       ; serial number YYMMDDNN
            28800   ; refresh  8 hours 
            7200    ; retry    2 hours
            864000  ; expire  10 days
            86400 ) ; min ttl  1 day
	NS      ${thishost}.${domain}
        
			A		${redir_spf}
;
@	IN		A		${redir_spf}
*	IN		A		${redir_spf}
End-of-message

    file=/etc/bind/named.conf.local
cat <<End-of-message>${file}
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
include "/etc/bind/zones.rfc1918";
include "/etc/bind/rndc.key";
include "/etc/dhcp/ddns.key";
${blist}

controls {
        inet 127.0.0.1 allow { localhost; } keys { "DDNS_UPDATE"; };
};

zone "${domain}" {
        type master;
        file "/etc/bind/db.${domain}";
        allow-update { key "DDNS_UPDATE"; };
};

zone "${iprev}.in-addr.arpa" {
        type master;
        file "/etc/bind/db.${iprev}";
        allow-update { key "DDNS_UPDATE"; };
};
End-of-message

}

do_dbrecords()
{
    file=/tmp/dnsbatch.txt

    domain=${10}
    rzn=$(echo "${9}"|sed s/"\."/" "/g|awk '{printf "%s.%s.%s.in-addr.arpa",$3,$2,$1}')
    shift 14

    cnt=$#

    if (( "${cnt}" <= 1 )); then return; fi

    echo "server 127.0.0.1" > "${file}"

    while true
    do
 
    if (( "${cnt}" <= 0 )); then break; fi        
        if (( "${1}" > 0 )); then
            rv=$(echo "${3}"|sed s/"\."/" "/g|awk '{printf "%s.%s.%s.%s.in-addr.arpa",$4,$3,$2,$1}')
            echo "zone ${domain}" >> "${file}" 
            echo "update delete ${2}.${domain}" >> "${file}"
            echo "send" >> "${file}"
            echo "zone ${rzn}" >> "${file}"
            echo "update delete ${rv}. PTR ${2}.${domain}." >> "${file}"
            echo "send" >> "${file}"       
            if (( "${1}" == 1 )); then
                echo "zone ${domain}" >> "${file} "    
                echo "update add ${2}.${domain} 86400 A ${3}" >> "${file}"
                echo "send" >> "${file}"
                echo "zone ${rzn}" >> "${file}"
                echo "update add ${rv}. 86400 PTR ${2}.${domain}." >> "${file}"
                echo "send" >> "${file}"
            fi
        fi
        shift 3
        cnt=$(("${cnt}"-3))
    done
    key=$(grep key  /etc/dhcp/ddns.key | awk '{print $2}')
    sec=$(grep secret /etc/dhcp/ddns.key | awk -F\" '{print $2}')
    /usr/bin/nsupdate -y "${key}:${sec}" "${file}"
}
 
do_vrules()
{
    base="/etc/shorewall"
    rules="${base}/rules"

    prefix=${2}
    shift 2
    cnt=$#

    nip=$(ip addr show "$( grep LOC_IF ${base}/interfaces |  grep -o '[^=]*$')" | grep -v secondary | grep "inet\b" | awk '{print $2}' | cut -d/ -f1)

    if (("${cnt}" >= 10 )); then
        cp "${base}"/bridge/rules "${rules}"
        rm -f "${base}"/macro.*
        echo "# BRIDGE USER RULES" >> "${rules}"
        while true
        do          
            if (("${cnt}" < 11 )); then break; fi
            if [ "${2}" = "0" ] && [ "${3}" != "0" ] && [ "${9}" != "0" ]; then
                if [ "${1}" = "0" ]; then st="#"; else st=""; fi
                if [ "${8}" != "oth" ]; then proto="${8}"; else proto="${11}"S; fi
                if [ "${nip}" = "${9}" ]; then dest="\$FW"; else dest="loc"; fi
                echo -e "${st}${prefix}${4}"\(DNAT\)'\t'"net"'\t'"${dest}:${9}:${10}"'\t'"${proto}"'\t'"${7}"'\t'\# "${3}:${5}" >> "${rules}"
                echo 'PARAM		-	-	-	-	-' > "${base}/macro.${prefix}${4}"
            fi
            shift 11
            cnt=$(("${cnt}" -11))
        done
    fi
}

do_ddns()
{
    shift 1

    enable=${1}
    domain=${2}
    account=${3}
    password=${4}
    provider=${5}
    lan_if=${6}

    file=/etc/ddclient.conf

    case ${provider} in
        0)
            proto="dyndns2"
            options="use=web, web=checkip.dyndns.com, web-skip='IP Address'"
            server="members.dyndns.org"
        ;;
        1)
            proto="easydns"
            options="use=if, if=${lan_if}"
            server="members.easydns.com"
        ;;
        2)
            proto="dslreports"
            options="use=if, if=${lan_if}"
            server="www.dslreports.com"
        ;;
        3)
            proto="zoneedit1"
            options="use=if, if=${lan_if}"
            server="dynamic.zoneedit.com"
        ;;
    esac
        
cat <<End-of-message>"${file}"
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# provider=${provider}
###############################################################################
protocol=${proto}                                                                
${options}                          
server=${server}                                                       
login=${account}                                                                 
password='${password}'                                                            
${domain} 
End-of-message

     if (("${enable}" == 0 )); then
        /usr/bin/systemctl stop ddclient
        sleep 3
        if [ -f /var/run/ddclient.pid ]; then
            kill -TERM "$(cat /var/run/ddclient.pid)"
            rm -f /var/run/ddclient.pid
            /usr/bin/systemctl disable ddclient
        fi
    else
        /usr/bin/systemctl enable ddclient
        /usr/bin/systemctl restart ddclient 
    fi

}

# shellcheck disable=SC2034

do_vpn()
{

    shift 1

    if=${1}
    network=${2}
    ns1=${3}
    enable=${6}
    how=${12}
    nconn=${13}
 
    case ${how} in
        [0-1])
            type="pptpd"
            file1="/etc/pptpd.conf"
            file2="/etc/ppp/pptpd-options"
            file3="/etc/ppp/ip-up.d/100forwarding"
            file4="/etc/ppp/ip-down.d/100forwarding"
            file5="/etc/ppp/chap-secrets"
            nconn=$(( "${nconn}" +2 ))
            if (( "${how}" == 1 )); then enc="require-mppe-128"; fi
        ;;
        *)
            return
        ;;
    esac

cat <<End-of-message>"${file1}"
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
option /etc/ppp/pptpd-options
logwtmp
bcrelay ${if}
localip ${network}.1
remoteip ${network}.2-${nconn}
End-of-message

cat <<End-of-message>"${file2}"
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# type=${how}
###############################################################################
name pptpd
refuse-pap
refuse-chap
refuse-mschap
require-mschap-v2
nodefaultroute
lock
nobsdcomp
ms-dns ${ns1}
ms-dns 8.8.4.4
noipx
mtu 1490
mru 1490
lcp-echo-adaptive
lcp-echo-failure 3
lcp-echo-interval 600
noipv6
${enc}
End-of-message

cat <<End-of-message>"${file3}"
#!/bin/sh
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
NET="\`echo \${PPP_LOCAL} | cut -d. -f1-3\`.0/24"
LIF=\`/sbin/ip route | awk '/default/ {print \$NF}'\`
COMMENT="VPN_PPP_\${PPP_IFACE}"
/sbin/iptables -t nat -m comment --comment "\${COMMENT}" -A POSTROUTING -s \${NET} -o \${LIF} -j MASQUERADE
/sbin/iptables -I FORWARD -m comment --comment "\${COMMENT}" -p tcp --tcp-flags SYN,RST SYN -i \${PPP_IFACE} -j TCPMSS --set-mss 1356
exit 0
End-of-message

cat <<End-of-message>"${file4}"
#!/bin/sh
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
COMMENT="VPN_PPP_\${PPP_IFACE}"
/sbin/iptables-save | grep -v "\${COMMENT}" | iptables-restore
exit 0
End-of-message

cat <<End-of-message>"${file5}"
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
# Secrets for authentication using CHAP
# client	server	secret		IP addresses
End-of-message

    shift 13

    cnt=$#
    while true
    do      
        if (("${cnt}" <= 0 )); then break; fi
        cnt=$(("${cnt}"-3 ))
        if (("${3}" == 0 )); then continue; fi
        echo "${1}	*	${2}	*" >> "${file5}"
        shift 3      
    done

    chmod 754 "${file3}" "${file4}"
   
    if (("${enable}" == 0 )); then
        /usr/bin/systemctl stop pptpd
        /usr/bin/systemctl disable pptpd
    else
        /usr/bin/systemctl enable pptpd
        /usr/bin/systemctl restart pptpd 
    fi

}

do_firewall_masqif()
{
    wan=${2}
    lan=${3}
    mask=$(ifconfig "${lan}"| grep -i netmask | awk -F' ' '{print $4}')
    ip=$(ifconfig "${lan}" | grep -m1 inet | awk '{printf $2}')
    net=$(ipcalc -b "${ip}" "${mask}"| grep Network: | awk '{print $2 }')

    if [ -f /etc/shorewall/tunnels ]; then
       vpnif="loc	ppp+"
    fi
    
    if [ "${4}" != "0" ]; then
        srvif="${4}"
        srvip="${5}"
        srvnet=$(ipcalc -b "${srvip}" 255.255.255.0 | grep Network: | awk '{print $2 }')
    fi

    extraloc=""
    extrasnat=""
    if [ -f /etc/dhcp/extra.conf ]; then
        # include subnet declarations outside the config scoop of this app
        extraif=$(grep  interface /etc/dhcp/extra.conf | awk -F\" '{print $2}')
        if [ -n "${extraif}" ]; then
            extraloc="loc	LOC_IF1		dhcp,tcpflags,nosmurfs,routefilter,logmartians=0,physical=${extraif}"
            srvip=$(grep subnet /etc/dhcp/extra.conf | awk '{printf $2}')
            enet=$(ipcalc -b "${srvip}" 255.255.255.0 | grep Network: | awk '{print $2 }')
            extrasnat=$(echo -e "MASQUERADE\t${enet}\t${wan}")
        fi
    fi
    
    file=/etc/shorewall/interfaces

cat <<End-of-message>"${file}"
# Shorewall version 5.1 - Interface file for two-interface configuration.
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
?FORMAT 2
###############################################################################
#ZONE   INTERFACE       OPTIONS
net	NET_IF 		dhcp,tcpflags,nosmurfs,routefilter,logmartians=0,sourceroute=0,physical=${wan}
loc	LOC_IF0		dhcp,tcpflags,nosmurfs,routefilter,logmartians=0,physical=${lan}
${extraloc}
${vpnif}
End-of-message

    if [ -n "${srvif}" ]; then
        if ! grep -q "${srvif}" "${file}"; then
            echo "loc	${srvif}" >> "${file}"
        else
            unset srvnet
        fi
    fi

    file=/etc/shorewall/snat

cat <<End-of-message>"${file}"
# Shorewall version 5.1 - Snat file for two-interface configuration.
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
#ACTION		SOURCE		DEST
MASQUERADE	${net}	${wan}
${extrasnat}
End-of-message

    if [ -n "${srvnet}" ]; then
        echo "SNAT(${srvip})	${srvnet}	${srvif}:srv" >> "${file}"
    fi
}

do_firewall_ts()
{

    file=/etc/shorewall/tcinterfaces
    
    if (( ${2} == 0 )); then rm -f "${file}"; return; fi

cat <<End-of-message>"${file}"
# Shorewall version 5.1 - Traffic shaping file
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
#INTERFACE	TYPE		IN-BANDWIDTH	OUT-BANDWIDTH
${5}		-		${3}mbit			${4}mbit
End-of-message
 
}

do_firewall_fws()
{

    shift 1

    base="/etc/shorewall"
    rules="${base}/rules"

    cp "${base}/bridge/rules" /tmp/rules
   
    if (( ${1} == 1 )); then
        echo "SSH(ACCEPT)		loc	\$FW" >> /tmp/rules
    else
        echo "SSH(REJECT)		loc	\$FW" >> /tmp/rules
    fi
  
    if (( ${2} == 1 )); then                         
        echo "ACCEPT			loc	\$FW	udp	111	# portmap" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	tcp	111	# portmap" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	udp	2049	# nfs" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	tcp	2049	# nfs" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	tcp	32764:32769	# nfs dyn-ports" >> /tmp/rules
        echo "ACCEPT			loc	\$FW	udp	32764:32769	# nfs dyn-ports" >> /tmp/rules
    else
        echo "REJECT			loc	\$FW	udp	111	# portmap" >> /tmp/rules
        echo "REJECT			loc	\$FW	tcp	111	# portmap" >> /tmp/rules
        echo "REJECT			loc	\$FW	udp	2049	# nfs" >> /tmp/rules
        echo "REJECT			loc	\$FW	tcp	2049	# nfs" >> /tmp/rules
        echo "REJECT			loc	\$FW	tcp	32764:32769	# nfs dyn-ports" >> /tmp/rules
        echo "REJECT			loc	\$FW	udp	32764:32769	# nfs dyn-ports" >> /tmp/rules
    fi

    
    if (( ${3} == 1 )); then
        echo "ACCEPT			net	\$FW	tcp	1723	# VPN (pptpd)" >> /tmp/rules

        echo "# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN" > ${base}/tunnels
        echo "#TYPE		ZONE	GATEWAY		GATEWAY ZONE" >> "${base}/tunnels"
        echo "pptpserver      loc              0.0.0.0/0" >> "${base}/tunnels"
        if ! grep -q "ppp+" "${base}/interfaces"; then
            echo "loc	ppp+" >> "${base}/interfaces"
        fi

    else
        rm -f "${base}/tunnels"
    fi

    echo "# BRIDGE USER RULES" >> /tmp/rules

    r=$(find ${base} -name 'macro.*' | cut -d. -f2)

    for ar in ${r}
    do
        grep -m1 "${ar}" "${rules}" >> /tmp/rules
    done
    cp /tmp/rules "${rules}"
}

do_cifs_disk()
{
    shift 2

    #/dev/sda1 1000GB ext4 9abae530-08e7-11e4-b529-5f1874a9b93e 2 0 HEDMANSHOME utf8 panda-drop N/A N/A 0 0

    fstype=${3}
    uuid=${4}
    action=${5}

    ext="bridge"
    mkdir -p /media/${ext}

    case ${action} in
        3)
            max=$(parted "${1}" unit s print free | grep 'Free Space' | tail -n 1 | awk -Fs '{print $2}')
            #start=$(parted ${1} unit s print free | grep 'Free Space' | tail -n 1 | awk -Fs '{print $1}')
            start=2048
            end=$(echo "${max}*${2}" | bc | awk '{print int($1-0.5)}')
            
            parted -s -a optimal "${1}" unit s mkpart primary "${3} ${start}s ${end}s"
            $SHELL -c "nohup mkfs.${3} ${1}1 -U ${4} >/tmp/mkfs.${3}"
        ;;
        4)
            /usr/bin/systemctl stop smbd nmbd
            sync;
            umount "/media/${ext}/${uuid}"
            sleep 2
            if grep -q "/media/${ext}/${uuid}" /proc/mounts; then return; fi
            rm -rf "/media/${ext:?}/"*
            osize=$(wc -l /etc/fstab | awk '{ print $1 }')
            grep -v "${uuid}" /etc/fstab > /tmp/fstab
            nsize=$(($(wc -l /etc/fstab | awk '{print $1}' ) +1))
            if (( "${osize}" == "${nsize}" )); then
                cp /tmp/fstab /etc/fstab
            fi
            return          
        ;;
    esac


    curdisk=$(ls /media/${ext})
    if [ -n "${curdisk}" ]; then
        if ! grep -q "${curdisk}" /etc/fstab; then
            rm -rf "/media/${ext:?}/"*
            curdisk=""
        fi
    fi
 
    cp /etc/fstab /tmp/fstab.orig
    rm -f /tmp/fstab
    ismount=1

    if [ "${curdisk}" != "${uuid}" ]; then
        if [ -n "${curdisk}" ]; then
            grep -q /media/"${ext}/${curdisk}" /proc/mounts
            ismount=$?
            umount /media/"${ext}/${curdisk}" 2> /dev/null
            sleep 2
            if grep -q /media/"${ext}/${curdisk}" /proc/mounts; then return; fi
            rm -rf "/media/${ext:?}/"*
        fi
        osize=$(wc -l /etc/fstab | awk '{ print $1 }')
        if [ -n "${curdisk}" ]; then
            grep -v "${curdisk}" /etc/fstab > /tmp/fstab
        else
            cp /etc/fstab /tmp/fstab
        fi
        echo "UUID=${uuid} /media/${ext}/${uuid}  ${fstype}  defaults,noatime  0  0" >> /tmp/fstab
        nsize=$(wc -l /tmp/fstab | awk '{ print $1 }')

        if [ -n  "${curdisk}" ]; then
            if (( "${osize}" != "${nsize}" )); then return; fi
        else
            osize=$(("${osize}" +1))
            if (( "${osize}" != "${nsize}" )); then return; fi
        fi
        cp /tmp/fstab /etc/fstab
        mkdir -p /media/"${ext}/${uuid}"
        chmod -R 755 /media/"${ext}/${uuid}"
        mount /media/"${ext}/${uuid}"
        if ! grep -q /media/"${ext}/${uuid}" /proc/mounts; then
            rmdir /media/"${ext}/${uuid}"
            cp /tmp/fstab.orig /etc/fstab
            mkdir -p /media/"${ext}/${curdisk}"
            chmod -R 755 /media/"${ext}/${curdisk}"
            if (( "${ismount}" == 0 )); then
                mount /media/"${ext}/${curdisk}"
            fi
            return
        fi
        mkdir -p /media/"${ext}/${uuid}/${uuid}"
        chmod -R 755 /media/"${ext}/${uuid}/${uuid}"
    fi

    /usr/bin/systemctl restart smbd nmbd
}

do_cifs()
{
    shift 7

    uuid=${1}
    workg=${2}
    chars=${3}

    file=/etc/samba/smb.conf

cat <<End-of-message>"${file}"
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
[global]

unix charset = ${chars}
workgroup = ${workg}
dns proxy = no
log file = /var/log/samba/log.%m
max log size = 1000
syslog = 0
security = share
passdb backend = tdbsam
obey pam restrictions = yes
domain master = auto
encrypt passwords = true
unix password sync = yes
passwd program = /usr/bin/passwd %u
passwd chat = *Enter\snew\s*\spassword:* %n\n *Retype\snew\s*\spassword:* %n\n *password\supdated\ssuccessfully*
pam password change = yes
map to guest = bad user
hide dot files = yes

End-of-message

    shift 3

    ext="bridge"
    root="/media/${ext}/${uuid}/${uuid}"
    cnt=$#
    while true
    do
        if (( "${cnt}" < 0 )); then break; fi
        cnt=$(("${cnt}"-5))

        if (( "${5}" == 3 )); then
            if (( "${4}" == 1 )); then
                smbpasswd -x "${2}"
                userdel "${2}"
            fi
            continue
        fi
        
        echo "[${1}]" >> "${file}"
        if (( "${4}" == 1 )); then
            echo "    valid users = ${2}" >> "${file}"
        else
            echo "    guest ok = yes" >> "${file}"
        fi
        echo "    path = ${root}/${1}" >> "${file}"
        echo "    writeable = yes" >> "${file}"
        if (( "${4}" == 1 )); then
            echo "    read only = no" >> "${file}"
            echo "    guest ok = no" >> "${file}"
            echo "    create  mask = 0640" >> "${file}"
            echo "    directory mask = 0750" >> "${file}"
            echo "    comment = ${2}'s private folder" >> "${file}"
            mkdir -p "${root}/${1}"
            chmod -R 0750 "${root}/${1}"
            if (( "${5}" == 1 )); then
                $SHELL -c "useradd ${2} -p ${3} -M -s /bin/false"
                echo -ne "${3}\n${3}\n" | smbpasswd -a -s "${2}"
            fi
            chown "${2}:${2}" "${root}/${1}"
        else
            echo "    browseable = yes" >> "${file}"
            echo "    guest only = yes" >> "${file}"
            echo "    create  mask = 0644" >> "${file}"
            echo "    directory mask = 0755" >> "${file}"
            echo "    comment = ${1} - a public folder" >> "${file}"
            mkdir -p "${root}/${1}"
            chmod -R 0777 "${root}/${1}"
        fi
        echo "" >> "${file}"
        shift 5      
    done

    /usr/bin/systemctl restart smbd nmbd

}

do_transmission()
{
    enab=${1}   
    if (( "${2}"== 1 )); then auth="true"; else auth="false"; fi
    port=${3}
    dlp="${4}/transmission"
    user=${5}
    pw=${6}

    mkdir -p "${dlp}"
    chmod 0777 "${dlp}"

file=/var/lib/transmission-daemon/info/settings.json

cat <<End-of-message>${file}
{
    "alt-speed-down": 50, 
    "alt-speed-enabled": false, 
    "alt-speed-time-begin": 540, 
    "alt-speed-time-day": 127, 
    "alt-speed-time-enabled": false, 
    "alt-speed-time-end": 1020, 
    "alt-speed-up": 50, 
    "bind-address-ipv4": "0.0.0.0", 
    "bind-address-ipv6": "::", 
    "blocklist-enabled": false, 
    "blocklist-url": "http://www.example.com/blocklist", 
    "cache-size-mb": 4, 
    "dht-enabled": true, 
    "download-dir": "${dlp}", 
    "download-limit": 100, 
    "download-limit-enabled": 0, 
    "download-queue-enabled": true, 
    "download-queue-size": 5, 
    "encryption": 1, 
    "idle-seeding-limit": 30, 
    "idle-seeding-limit-enabled": false, 
    "incomplete-dir": "/root/Downloads", 
    "incomplete-dir-enabled": false, 
    "lpd-enabled": false, 
    "max-peers-global": 200, 
    "message-level": 2, 
    "peer-congestion-algorithm": "", 
    "peer-limit-global": 240, 
    "peer-limit-per-torrent": 60, 
    "peer-port": 51413, 
    "peer-port-random-high": 65535, 
    "peer-port-random-low": 49152, 
    "peer-port-random-on-start": false, 
    "peer-socket-tos": "default", 
    "pex-enabled": true, 
    "port-forwarding-enabled": false, 
    "preallocation": 1, 
    "prefetch-enabled": 1, 
    "queue-stalled-enabled": true, 
    "queue-stalled-minutes": 30, 
    "ratio-limit": 2, 
    "ratio-limit-enabled": false, 
    "rename-partial-files": true, 
    "rpc-authentication-required": ${auth}, 
    "rpc-bind-address": "0.0.0.0", 
    "rpc-enabled": true, 
    "rpc-password": "${pw}", 
    "rpc-port": ${port}, 
    "rpc-url": "/transmission/", 
    "rpc-username": "${user}", 
    "rpc-whitelist": "127.0.0.1", 
    "rpc-whitelist-enabled": false, 
    "scrape-paused-torrents-enabled": true, 
    "script-torrent-done-enabled": false, 
    "script-torrent-done-filename": "", 
    "seed-queue-enabled": false, 
    "seed-queue-size": 10, 
    "speed-limit-down": 100, 
    "speed-limit-down-enabled": false, 
    "speed-limit-up": 100, 
    "speed-limit-up-enabled": false, 
    "start-added-torrents": true, 
    "trash-original-torrent-files": false, 
    "umask": 18, 
    "upload-limit": 100, 
    "upload-limit-enabled": 0, 
    "upload-slots-per-torrent": 14, 
    "utp-enabled": true
}
End-of-message

    grep -v "transmission on fw" /etc/shorewall/rules > /tmp/rules
    if [ -s /tmp/rules ]; then
        cp /tmp/rules /etc/shorewall/rules
        rm -f /tmp/rules*
    fi
    grep -v "transmission on fw" /etc/shorewall/bridge/rules > /tmp/rules
    if [ -s /tmp/rules ]; then
        cp /tmp/rules /etc/shorewall/bridge/rules
        rm -f /tmp/rules*
    fi

    if (( "${enab}" == 1 )); then
        sed "8aACCEPT			loc	\$FW 	tcp	${port}	# transmission on fw" /etc/shorewall/rules > /tmp/rules.tmp
        sed "9aACCEPT			net	\$FW 	tcp	${port}	# transmission on fw" /tmp/rules.tmp  > /tmp/rules
        if [ -s /tmp/rules ]; then
            cp /tmp/rules /etc/shorewall/rules
            rm -f /tmp/rules*
        fi
        sed "11aACCEPT			loc	\$FW 	tcp	${port}	# transmission on fw" /etc/shorewall/bridge/rules > /tmp/rules.tmp
        sed "12aACCEPT			net	\$FW 	tcp	${port}	# transmission on fw" /tmp/rules.tmp  > /tmp/rules
        if [ -s /tmp/rules ]; then
            cp /tmp/rules /etc/shorewall/bridge/rules
        fi
    fi
    rm -f /tmp/rules*

}

do_fwlog()
{
    shift 2
    
    if (( "${1}" == 1 )); then dlog="\$LOG_LEVEL"; else dlog=""; fi
    if (( "${2}" == 1 )); then rlog="\$LOG_LEVEL"; else rlog=""; fi

    file=/etc/shorewall/policy

cat <<End-of-message>"${file}"
# Shorewall version 5.1 - Policy file
#------------------------------------------------------------------------------
# DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
###############################################################################
#SOURCE		DEST		POLICY		LOG LEVEL	RATE	CONNLIMIT
\$FW        	net		ACCEPT
loc		net		ACCEPT
net		all		DROP		$dlog
# THE FOLLOWING POLICY MUST BE LAST
all		all		REJECT		$rlog
End-of-message

}
